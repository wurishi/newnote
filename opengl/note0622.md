*NeHe OpenGL教程（中英文版附带VC++源码）中英文系列
**

# Link

Lesson 01-lesson 02
创建一个OpenGL窗口:
如何创建三角形和四边形
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=53679

 

Lesson 03-lesson 04
添加颜色
旋转
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=53682

Lesson 05-lesson 06
3D空间
纹理映射
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=53706

Lesson 07-lesson 08
光照和键盘控制
混合
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=53709

Lesson 09-lesson 10
3D空间中移动图像
加载3D世界，并在其中漫游
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=53822

Lesson 11-lesson 12
飘动的旗帜
显示列表
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=53823

Lesson 13-lesson 14

 

 

http://www.ieee.org.cn/dispbbs.asp?boardID=61&ID=54065


图像字体
图形字体
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=53880

Lesson 15-lesson 16
图形字体的纹理映射
雾
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=53881

Lesson 17-lesson 18
2D 图像文字
二次几何体
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54042

Lesson 19-lesson 20
粒子系统
蒙板
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54072

Lesson 21-lesson 22
线，反走样，计时，正投影和简单的声音
凹凸映射，多重纹理扩展
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54074

Lesson 23-lesson 24
球面映射
扩展，剪裁和TGA图像文件的加载
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54176

Lesson 25-lesson 26
变形和从文件中加载3D物体
剪裁平面，蒙板缓存和反射
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54177

Lesson 27-lesson 28
影子
贝塞尔曲面
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54180

Lesson 29-lesson 30
Blitter 函数
碰撞检测
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54186

Lesson 31-lesson 32
模型加载
拾取, Alpha混合, Alpha测试, 排序
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54209

Lesson 33-lesson 34
加载压缩和未压缩的TGA文件
从高度图生成地形
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54271

Lesson 35-lesson 36
在OpenGL中播放AVI
放射模糊和渲染到纹理
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54289

Lesson 37-lesson 38
卡通映射
从资源文件中载入图像
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54290

Lesson 39-lesson 40
物理模拟简介
绳子的模拟
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54706

Lesson 41-lesson 42
体积雾气
多重视口
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54707

Lesson 43-lesson 44
在OpenGL中使用FreeType库
3D 光晕
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54710

Lesson 45-lesson 46
顶点缓存
全屏反走样
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54729

Lesson 47-lesson 48
CG 顶点脚本
轨迹球实现的鼠标旋转
http://ieee.org.cn/dispbbs.asp?boardID=61&ID=54730

# 第一课 创建一个OpenGL窗口

在这个教程里,我将教你在Windows环境中创建OpenGL程序.它将显示一个空的OpenGL窗口,可以在窗口和全屏模式下切换,按ESC退出.它是我们以后应用程序的框架.

理解OpenGL如何工作非常重要，你可以在教程的末尾下载源程序，但我强烈建议你至少读一遍教程，然后再开始编程.

欢迎来到我的 OpenGL教程。我是个对 OpenGL充满激情的普通男孩！ 我第一次听说 OpenGL是 3Dfx 发布 Voodoo1 卡的 OpenGL硬件加速驱动的时候。我立刻意识到 OpenGL是那种必须学习的东西。不幸的是当时很难从书本或网络上找到关于 OpenGL的讯息。我花了 N 个 小时来调试自己书写的代码，甚至在 IRC和 EMail 上花更多的时间来恳求别人帮忙。但我发现那 些懂得 OpenGL 高手们保留了他们的精华，对共享知识也不感兴趣。实在让人灰心 !
我创建这个网站的目的是为了帮助那些对 OpenGL有兴趣却又需要帮助的人。在我的每个教程中，我都会尽可能详细的来解释每一行代码的作用。我会努力让我的代码更简单（您无需学习 MFC代码）！就算您是个VC 、OPENGL的绝对新手也应该可以读通代码，并清楚的知道发生了什么。我的站点只是许多提供 OpenGL教程的站点中的一个。如果您是 OpenGL的高级程序员的话，我的站点可能太简单了，但如果您才开始的话，我想这个站点会教会您许多东西！
教程的这一节在2000年一月彻底重写了一遍。将会教您如何设置一个 OpenGL窗口。它可以只是一个窗口或是全屏幕的、可以任意 大小、任意色彩深度。此处的代码很稳定且很强大，您可以在您所有的OpenGL项目中使用。我所有的教程都将基于此节的代码！所有的错误都有被报告。所以应该没有内存泄漏，代码也很容易阅读和修改。感谢Fredric Echols对代码所做的修改！

现在就让我们直接从代码开始吧。第一件事是打开VC然后创建一个新工程。如果您不知道如何创建的话，您也许不该学习OpenGL，而应该先学学VC。某些版本的VC需要将 bool 改成 BOOL , true 改成 TRUE , false 改成 FALSE ，请自行修改。

在您创建一个新的Win32程序（不是console控制台程序）后，您还需要链接OpenGL库文件。在VC中操作如下：Project-> Settings,然后单击LINK标签。在"Object/Library Modules"选项中的开始处（在 kernel32.lib 前）增加 OpenGL32.lib GLu32.lib 和 GLaux.lib 后单击OK按钮。现在可以开始写您的OpenGL程序了。

代码的前4行包括了我们使用的每个库文件的头文件。如下所示：

```c
#include <windows.h> // Windows的头文件
#include <glew.h> // 包含最新的gl.h,glu.h库
#include <glut.h> // 包含OpenGL实用库
```

接下来您需要设置您计划在您的程序中使用的所有变量。本节中的例程将创建一个空的OpenGL窗口，因此我们暂时还无需设置大堆的变量。余下需要设置的变量不多，但十分重要。您将会在您以后所写的每一个OpenGL程序中用到它们。
第一行设置的变量是Rendering Context(着色描述表)。每一个OpenGL都被连接到一个着色描述表上。着色描述表将所有的OpenGL调用命令连接到Device Context(设备描述表)上。我将OpenGL的着色描述表定义为 hRC 。要让您的程序能够绘制窗口的话，还需要创建一个设备描述表，也就是第二行的内容。Windows的设备描述表被定义为 hDC 。DC将窗口连接到GDI(Graphics Device Interface图形设备接口)。而RC将OpenGL连接到DC。第三行的变量 hWnd 将保存由Windows给我们的窗口指派的句柄。最后，第四行为我们的程序创建了一个Instance(实例)。

```c
HGLRC hRC=NULL;    // 窗口着色描述表句柄
HDC hDC=NULL;    // OpenGL渲染描述表句柄
HWND hWnd=NULL;    // 保存我们的窗口句柄
HINSTANCE hInstance;    // 保存程序的实例
```

接下来您需要设置您计划在您的程序中使用的所有变量。本节中的例程将创建一个空的OpenGL窗口，因此我们暂时还无需设置大堆的变量。余下需要设置的变量不多，但十分重要。您将会在您以后所写的每一个OpenGL程序中用到它们。
第一行设置的变量是Rendering Context(着色描述表)。每一个OpenGL都被连接到一个着色描述表上。着色描述表将所有的OpenGL调用命令连接到Device Context(设备描述表)上。我将OpenGL的着色描述表定义为 hRC 。要让您的程序能够绘制窗口的话，还需要创建一个设备描述表，也就是第二行的内容。Windows的设备描述表被定义为 hDC 。DC将窗口连接到GDI(Graphics Device Interface图形设备接口)。而RC将OpenGL连接到DC。第三行的变量 hWnd 将保存由Windows给我们的窗口指派的句柄。最后，第四行为我们的程序创建了一个Instance(实例)。
HGLRC      hRC=NULL;    // 窗口着色描述表句柄
HDC       hDC=NULL;    // OpenGL渲染描述表句柄
HWND      hWnd=NULL;    // 保存我们的窗口句柄
HINSTANCE    hInstance;    // 保存程序的实例

下面的第一行设置一个用来监控键盘动作的数组。有许多方法可以监控键盘的动作，但这里的方法很可靠，并且可以处理多个键同时按下的情况。
active 变量用来告知程序窗口是否处于最小化的状态。如果窗口已经最小化的话，我们可以做从暂停代码执行到退出程序的任何事情。我喜欢暂停程序。这样可以使得程序不用在后台保持运行。
fullscreen 变量的作用相当明显。如果我们的程序在全屏状态下运行， fullscreen 的值为TRUE，否则为FALSE。这个全局变量的设置十分重要，它让每个过程都知道程序是否运行在全屏状态下。

```c
bool keys[256];    // 保存键盘按键的数组
bool active=TRUE;    // 窗口的活动标志，缺省为TRUE
bool fullscreen=TRUE;    // 全屏标志缺省，缺省设定成全屏模式
```

现在我们需要先定义WndProc()。必须这么做的原因是CreateGLWindow()有对WndProc()的引用，但WndProc()在CreateGLWindow()之后才出现。在C语言中，如果我们想要访问一个当前程序段之后的过程和程序段的话，必须在程序开始处先申明所要访问的程序段。所以下面的一行代码先行定义了WndProc()，使得CreateGLWindow()能够引用WndProc()。

```c
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);  // WndProc的定义
```

下面的代码的作用是重新设置OpenGL场景的大小，而不管窗口的大小是否已经改变(假定您没有使用全屏模式)。甚至您无法改变窗口的大小时(例如您在全屏模式下)，它至少仍将运行一次--在程序开始时设置我们的透视图。OpenGL场景的尺寸将被设置成它显示时所在窗口的大小。

```c
GLvoid ReSizeGLScene(GLsizei width, GLsizei height)  // 重置OpenGL窗口大小
{
    if (height == 0) // 防止被零除
    {
        height=1;    // 将Height设为1
    }
    glViewport(0, 0, width, height);   // 重置当前的视口
```

下面几行为透视图设置屏幕。意味着越远的东西看起来越小。这么做创建了一个现实外观的场景。此处透视按照基于窗口宽度和高度的45度视角来计算。0.1f，100.0f是我们在场景中所能绘制深度的起点和终点。
glMatrixMode(GL_PROJECTION)指明接下来的两行代码将影响projection matrix(投影矩阵)。投影矩阵负责为我们的场景增加透视。 glLoadIdentity()近似于重置。它将所选的矩阵状态恢复成其原始状态。调用 glLoadIdentity()之后我们为场景设置透视图。
glMatrixMode(GL_MODELVIEW)指明任何新的变换将会影响 modelview matrix(模型观察矩阵)。模型观察矩阵中存放了我们的物体讯息。最后我们重置模型观察矩阵。如果您还不能理解这些术语的含义，请别着急。在以后的教程里，我会向大家解释。只要知道如果您想获得一个精彩的透视场景的话，必须这么做。

```c
    glMatrixMode(GL_PROJECTION);   // 选择投影矩阵
    glLoadIdentity();    // 重置投影矩阵

    // 设置视口的大小
    gluPerspective(45.0f,(GLfloat)width/(GLfloat)height,0.1f,100.0f);

    glMatrixMode(GL_MODELVIEW);   // 选择模型观察矩阵
    glLoadIdentity();    // 重置模型观察矩阵
}
```

接下的代码段中，我们将对OpenGL进行所有的设置。我们将设置清除屏幕所用的颜色，打开深度缓存，启用smooth shading(阴影平滑)，等等。这个例程直到OpenGL窗口创建之后才会被调用。此过程将有返回值。但我们此处的初始化没那么复杂，现在还用不着担心这个返回值。

```c
int InitGL(GLvoid)    // 此处开始对OpenGL进行所有设置
{
```

下一行启用smooth shading(阴影平滑)。阴影平滑通过多边形精细的混合色彩，并对外部光进行平滑。我将在另一个教程中更详细的解释阴影平滑。

```c
	glShadeModel(GL_SMOOTH);   // 启用阴影平滑
```

下一行设置清除屏幕时所用的颜色。如果您对色彩的工作原理不清楚的话，我快速解释一下。色彩值的范围从0.0f到1.0f。0.0f代表最黑的情况，1.0f就是最亮的情况。glClearColor 后的第一个参数是Red Intensity(红色分量),第二个是绿色，第三个是蓝色。最大值也是1.0f，代表特定颜色分量的最亮情况。最后一个参数是Alpha值。当它用来清除屏幕的时候，我们不用关心第四个数字。现在让它为0.0f。我会用另一个教程来解释这个参数。
通过混合三种原色(红、绿、蓝)，您可以得到不同的色彩。希望您在学校里学过这些。因此，当您使用glClearColor(0.0f,0.0f,1.0f,0.0f)，您将用亮蓝色来清除屏幕。如果您用 glClearColor(0.5f,0.0f,0.0f,0.0f)的话，您将使用中红色来清除屏幕。不是最亮(1.0f)，也不是最暗 (0.0f)。要得到白色背景，您应该将所有的颜色设成最亮(1.0f)。要黑色背景的话，您该将所有的颜色设为最暗(0.0f)。

```c
	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);   // 黑色背景
```

接下来的三行必须做的是关于depth buffer(深度缓存)的。将深度缓存设想为屏幕后面的层。深度缓存不断的对物体进入屏幕内部有多深进行跟踪。我们本节的程序其实没有真正使用深度缓存，但几乎所有在屏幕上显示3D场景OpenGL程序都使用深度缓存。它的排序决定那个物体先画。这样您就不会将一个圆形后面的正方形画到圆形上来。深度缓存是OpenGL十分重要的部分。

```c
    glClearDepth(1.0f);    // 设置深度缓存
    glEnable(GL_DEPTH_TEST);   // 启用深度测试
    glDepthFunc(GL_LEQUAL);    // 所作深度测试的类型
```

接着告诉OpenGL我们希望进行最好的透视修正。这会十分轻微的影响性能。但使得透视图看起来好一点。

```c
	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);  // 告诉系统对透视进行修正
```

最后，我们返回TRUE。如果我们希望检查初始化是否OK，我们可以查看返回的 TRUE或FALSE的值。如果有错误发生的话，您可以加上您自己的代码返回FALSE。目前，我们不管它。

```c
	return TRUE;    // 初始化 OK
}
```

下一段包括了所有的绘图代码。任何您所想在屏幕上显示的东东都将在此段代码中出现。以后的每个教程中我都会在例程的此处增加新的代码。如果您对OpenGL已经有所了解的话，您可以在 glLoadIdentity()调用之后，返回TRUE值之前，试着添加一些OpenGL代码来创建基本的形。如果您是OpenGL新手，等着我的下个教程。目前我们所作的全部就是将屏幕清除成我们前面所决定的颜色，清除深度缓存并且重置场景。我们仍没有绘制任何东东。
返回TRUE值告知我们的程序没有出现问题。如果您希望程序因为某些原因而中止运行，在返回TRUE值之前增加返回FALSE的代码告知我们的程序绘图代码出错。程序即将退出。

```c
int DrawGLScene(GLvoid)    // 从这里开始进行所有的绘制
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // 清除屏幕和深度缓存
    glLoadIdentity();    // 重置当前的模型观察矩阵
    return TRUE;    // 一切 OK
}
```

下一段代码只在程序退出之前调用。KillGLWindow() 的作用是依次释放着色描述表，设备描述表和窗口句柄。我已经加入了许多错误检查。如果程序无法销毁窗口的任意部分，都会弹出带相应错误消息的讯息窗口，告诉您什么出错了。使您在您的代码中查错变得更容易些。

```c
GLvoid KillGLWindow(GLvoid)    // 正常销毁窗口
{
```

我们在KillGLWindow()中所作的第一件事是检查我们是否处于全屏模式。如果是，我们要切换回桌面。我们本应在禁用全屏模式前先销毁窗口，但在某些显卡上这么做可能会使得桌面崩溃。所以我们还是先禁用全屏模式。这将防止桌面出现崩溃，并在Nvidia和3dfx显卡上都工作的很好！

```c
    if (fullscreen)    // 我们处于全屏模式吗?
    {
```

我们使用ChangeDisplaySettings(NULL,0)回到原始桌面。将NULL作为第一个参数，0作为第二个参数传递强制Windows使用当前存放在注册表中的值(缺省的分辨率、色彩深度、刷新频率，等等)来有效的恢复我们的原始桌面。切换回桌面后，我们还要使得鼠标指针重新可见。

```c
        ChangeDisplaySettings(NULL,0);   // 是的话，切换回桌面
        ShowCursor(TRUE);   // 显示鼠标指针
    }
```

接下来的代码查看我们是否拥有着色描述表(hRC)。如果没有，程序将跳转至后面的代码查看是否拥有设备描述表。

```c 
    if (hRC)    // 我们拥有OpenGL渲染描述表吗?
    {
```

如果存在着色描述表的话，下面的代码将查看我们能否释放它(将 hRC从hDC分开)。这里请注意我使用的的查错方法。基本上我只是让程序尝试释放着色描述表(通过调用wglMakeCurrent(NULL,NULL)，然后我再查看释放是否成功。巧妙的将数行代码结合到了一行。

```c
        if (!wglMakeCurrent(NULL,NULL))   // 我们能否释放DC和RC描述表?
        {
```

如果不能释放DC和RC描述表的话，MessageBox()将弹出错误消息，告知我们DC和RC无法被释放。NULL意味着消息窗口没有父窗口。其右的文字将在消息窗口上出现。"SHUTDOWN ERROR"出现在窗口的标题栏上。MB_OK的意思消息窗口上带有一个写着OK字样的按钮。
MB_ICONINFORMATION将在消息窗口中显示一个带圈的小写的i(看上去更正式一些)。 

```c
        	MessageBox(NULL,"释放DC或RC失败。","关闭错误",MB_OK | MB_ICONINFORMATION);
        }
```

下一步我们试着删除着色描述表。如果不成功的话弹出错误消息。 

```c
        if (!wglDeleteContext(hRC))   // 我们能否删除RC?
        {
```

如果无法删除着色描述表的话，将弹出错误消息告知我们RC未能成功删除。然后hRC被设为NULL。

```c
			MessageBox(NULL,"释放RC失败。","关闭错误",MB_OK | MB_ICONINFORMATION);
		}
		hRC=NULL;    // 将RC设为 NULL
	}
```

现在我们查看是否存在设备描述表，如果有尝试释放它。如果不能释放设备描述表将弹出错误消息，然后hDC设为NULL。

```c
    if (hDC && !ReleaseDC(hWnd,hDC))   // 我们能否释放 DC?
    {
        MessageBox(NULL,"释放DC失败。","关闭错误",MB_OK | MB_ICONINFORMATION);
        hDC=NULL;    // 将 DC 设为 NULL
    }
```

现在我们来查看是否存在窗口句柄，我们调用 DestroyWindow( hWnd )来尝试销毁窗口。如果不能的话弹出错误窗口，然后hWnd被设为NULL。

```c
    if (hWnd && !DestroyWindow(hWnd))   // 能否销毁窗口?
    {
        MessageBox(NULL,"释放窗口句柄失败。","关闭错误",MB_OK | MB_ICONINFORMATION);
        hWnd=NULL;    // 将 hWnd 设为 NULL
    }
```

最后要做的事是注销我们的窗口类。这允许我们正常销毁窗口，接着在打开其他窗口时，不会收到诸如"Windows Class already registered"(窗口类已注册)的错误消息。

```c
    if (!UnregisterClass("OpenG",hInstance))  // 能否注销类?
    {
        MessageBox(NULL,"不能注销窗口类。","关闭错误",MB_OK | MB_ICONINFORMATION);
        hInstance=NULL;    // 将 hInstance 设为 NULL
    }
}
```

接下来的代码段创建我们的OpenGL窗口。我花了很多时间来做决定是否创建固定的全屏模式这样不需要许多额外的代码，还是创建一个容易定制的友好的窗口但需要更多的代码。当然最后我选择了后者。我经常在EMail中收到诸如此类的问题：怎样创建窗口而不使用全屏幕?怎样改变窗口的标题栏?怎样改变窗口的分辨率或pixel format(象素格式)?以下的代码完成了所有这一切！尽管最好要学学材质，这会让您写自己的OpenGL程序变得容易的多！
正如您所见，此过程返回布尔变量(TRUE 或 FALSE)。他还带有5个参数：窗口的标题栏，窗口的宽度，窗口的高度，色彩位数(16/24/32)，和全屏标志(TRUE --全屏模式， FALSE--窗口模式 )。返回的布尔值告诉我们窗口是否成功创建。

```c
BOOL CreateGLWindow(char* title, int width, int height, int bits, bool fullscreenflag)
{
```

当我们要求Windows为我们寻找相匹配的象素格式时，Windows寻找结束后将模式值保存在变量PixelFormat中。

```c
	GLuint PixelFormat;   // 保存查找匹配的结果
```

wc用来保存我们的窗口类的结构。窗口类结构中保存着我们的窗口信息。通过改变类的不同字段我们可以改变窗口的外观和行为。每个窗口都属于一个窗口类。当您创建窗口时，您必须为窗口注册类。

```c
	WNDCLASS wc;    // 窗口类结构
```

dwExStyle和dwStyle存放扩展和通常的窗口风格信息。我使用变量来存放风格的目的是为了能够根据我需要创建的窗口类型(是全屏幕下的弹出窗口还是窗口模式下的带边框的普通窗口)；来改变窗口的风格。

```c
    DWORD dwExStyle;   // 扩展窗口风格
    DWORD dwStyle;   // 窗口风格
```

下面的5行代码取得矩形的左上角和右下角的坐标值。我们将使用这些值来调整我们的窗口使得其上的绘图区的大小恰好是我们所需的分辨率的值。通常如果我们创建一个640x480的窗口，窗口的边框会占掉一些分辨率的值。

```c
    RECT WindowRect;    // 取得矩形的左上角和右下角的坐标值
    WindowRect.left=(long)0;   // 将Left  设为 0
    WindowRect.right=(long)width;   // 将Right 设为要求的宽度
    WindowRect.top=(long)0;    // 将Top  设为 0
    WindowRect.bottom=(long)height;   // 将Bottom 设为要求的高度
```

下一行代码我们让全局变量fullscreen等于fullscreenflag。如果我们希望在全屏幕下运行而将fullscreenflag设为TRUE，但没有让变量fullscreen等于fullscreenflag的话，fullscreen变量将保持为FALSE。当我们在全屏幕模式下销毁窗口的时候，变量fullscreen的值却不是正确的TRUE值，计算机将误以为已经处于桌面模式而无法切换回桌面。上帝啊，但愿这一切都有意义。就是一句话，fullscreen的值必须永远fullscreenflag的值，否则就会有问题。 

```c
	fullscreen=fullscreenflag;   // 设置全局全屏标志
```

下一部分的代码中，我们取得窗口的实例，然后定义窗口类。
CS_HREDRAW 和 CS_VREDRAW 的意思是无论何时，只要窗口发生变化时就强制重画。CS_OWNDC为窗口创建一个私有的DC。这意味着DC不能在程序间共享。WndProc是我们程序的消息处理过程。由于没有使用额外的窗口数据，后两个字段设为零。然后设置实例。接着我们将hIcon设为NULL，因为我们不想给窗口来个图标。鼠标指针设为标准的箭头。背景色无所谓(我们在GL中设置)。我们也不想要窗口菜单，所以将其设为NULL。类的名字可以您想要的任何名字。出于简单，我将使用"OpenG"。

 

```c
    hInstance = GetModuleHandle(NULL);  // 取得我们窗口的实例
    wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC; // 移动时重画，并为窗口取得DC
    wc.lpfnWndProc = (WNDPROC) WndProc;  // WndProc处理消息
    wc.cbClsExtra = 0;   // 无额外窗口数据
    wc.cbWndExtra = 0;   // 无额外窗口数据
    wc.hInstance = hInstance;   // 设置实例
    wc.hIcon = LoadIcon(NULL, IDI_WINLOGO);  // 装入缺省图标
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);  // 装入鼠标指针
    wc.hbrBackground = NULL;   // GL不需要背景
    wc.lpszMenuName = NULL;   // 不需要菜单
    wc.lpszClassName = "OpenG";   // 设定类名字
```

现在注册类名字。如果有错误发生，弹出错误消息窗口。按下上面的OK按钮后，程序退出

```c
    if (!RegisterClass(&wc))   // 尝试注册窗口类
    {
        MessageBox(NULL,"注册窗口失败","错误",MB_OK|MB_ICONEXCLAMATION);
        return FALSE;    // 退出并返回FALSE
    }
```

查看程序应该在全屏模式还是窗口模式下运行。如果应该是全屏模式的话，我们将尝试设置全屏模式。

```c
    if (fullscreen)    // 要尝试全屏模式吗?
    {
```

下一部分的代码看来很多人都会有问题要问关于.......切换到全屏模式。在切换到全屏模式时，有几件十分重要的事您必须牢记。必须确保您在全屏模式下所用的宽度和高度等同于窗口模式下的宽度和高度。最最重要的是要在创建窗口之前设置全屏模式。这里的代码中，您无需再担心宽度和高度，它们已被设置成与显示模式所对应的大小。

```c
        DEVMODE dmScreenSettings;   // 设备模式
        memset(&dmScreenSettings,0,sizeof(dmScreenSettings));  // 确保内存清空为零
        dmScreenSettings.dmSize=sizeof(dmScreenSettings);  // Devmode 结构的大小
        dmScreenSettings.dmPelsWidth = width;  // 所选屏幕宽度
        dmScreenSettings.dmPelsHeight = height;  // 所选屏幕高度
        dmScreenSettings.dmBitsPerPel = bits;   // 每象素所选的色彩深度
        dmScreenSettings.dmFields=DM_BITSPERPEL|DM_PELSWIDTH|DM_PELSHEIGHT;
```

上面的代码中，我们分配了用于存储视频设置的空间。设定了屏幕的宽，高，色彩深度。下面的代码我们尝试设置全屏模式。我们在dmScreenSettings中保存了所有的宽，高，色彩深度讯息。下一行使用ChangeDisplaySettings来尝试切换成与dmScreenSettings所匹配模式。我使用参数CDS_FULLSCREEN来切换显示模式，因为这样做不仅移去了屏幕底部的状态条，而且它在来回切换时，没有移动或改变您在桌面上的窗口。

```c
        // 尝试设置显示模式并返回结果。注: CDS_FULLSCREEN 移去了状态条。
        if (ChangeDisplaySettings(&dmScreenSettings,CDS_FULLSCREEN)!=DISP_CHANGE_SUCCESSFUL)
        {
```

如果模式未能设置成功，我们将进入以下的代码。如果不能匹配全屏模式，弹出消息窗口，提供两个选项：在窗口模式下运行或退出。

```c
            // 若模式失败，提供两个选项：退出或在窗口内运行。
            if (MessageBox(NULL,"全屏模式在当前显卡上设置失败！\n使用窗口模式？","NeHe G",MB_YESNO|MB_ICONEXCLAMATION)==IDYES)
            {
```

如果用户选择窗口模式，变量fullscreen 的值变为FALSE,程序继续运行。

```c
            	fullscreen=FALSE;  // 选择窗口模式(Fullscreen=FALSE)
            }
            else
            {
```

如果用户选择退出，弹出消息窗口告知用户程序将结束。并返回FALSE告诉程序窗口未能成功创建。程序退出。

```c
                // 弹出一个对话框，告诉用户程序结束
                MessageBox(NULL,"程序将被关闭","错误",MB_OK|MB_ICONSTOP);
                return FALSE;   // 退出并返回 FALSE
            }
		}
	}
```

由于全屏模式可能失败，用户可能决定在窗口下运行，我们需要在设置屏幕/窗口之前，再次检查fullscreen的值是TRUE或FALSE。

```c
    if (fullscreen)    // 仍处于全屏模式吗?
    {
```

如果我们仍处于全屏模式，设置扩展窗体风格为WS_EX_APPWINDOW，这将强制我们的窗体可见时处于最前面。再将窗体的风格设为WS_POPUP。这个类型的窗体没有边框，使我们的全屏模式得以完美显示。
最后我们禁用鼠标指针。当您的程序不是交互式的时候，在全屏模式下禁用鼠标指针通常是个好主意。

```c
        dwExStyle=WS_EX_APPWINDOW;   // 扩展窗体风格
        dwStyle=WS_POPUP;   // 窗体风格
        ShowCursor(FALSE);   // 隐藏鼠标指针
    }
    else
    {
```

如果我们使用窗口而不是全屏模式，我们在扩展窗体风格中增加了 WS_EX_WINDOWEDGE，增强窗体的3D感观。窗体风格改用 WS_OVERLAPPEDWINDOW，创建一个带标题栏、可变大小的边框、菜单和最大化/最小化按钮的窗体。

```c
        dwExStyle=WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;  // 扩展窗体风格
        dwStyle=WS_OVERLAPPEDWINDOW;   // 窗体风格
    }
```

下一行代码根据创建的窗体类型调整窗口。调整的目的是使得窗口大小正好等于我们要求的分辨率。通常边框会占用窗口的一部分。使用AdjustWindowRectEx 后，我们的OpenGL场景就不会被边框盖住。实际上窗口变得更大以便绘制边框。全屏模式下，此命令无效。

```c
    AdjustWindowRectEx(&WindowRect, dwStyle, FALSE, dwExStyle); // 调整窗口达到真正要求的大小
```

下一段代码开始创建窗口并检查窗口是否成功创建。我们将传递CreateWindowEx()所需的所有参数。如扩展风格、类名字(与您在注册窗口类时所用的名字相同)、窗口标题、窗体风格、窗体的左上角坐标(0,0 是个安全的选择)、窗体的宽和高。我们没有父窗口，也不想要菜单，这些参数被设为NULL。还传递了窗口的实例，最后一个参数被设为NULL。
注意我们在窗体风格中包括了 WS_CLIPSIBLINGS 和 WS_CLIPCHILDREN。要让OpenGL正常运行，这两个属性是必须的。他们阻止别的窗体在我们的窗体内/上绘图。

```c
    if (!(hWnd=CreateWindowEx( dwExStyle,  // 扩展窗体风格
                              "OpenG",  // 类名字
                              title,   // 窗口标题
                              WS_CLIPSIBLINGS |  // 必须的窗体风格属性
                              WS_CLIPCHILDREN |  // 必须的窗体风格属性
                              dwStyle,  // 选择的窗体属性
                              0, 0,   // 窗口位置
                              WindowRect.right-WindowRect.left, // 计算调整好的窗口宽度
                              WindowRect.bottom-WindowRect.top, // 计算调整好的窗口高度
                              NULL,   // 无父窗口
                              NULL,   // 无菜单
                              hInstance,  // 实例
                              NULL)))   // 不向WM_CREATE传递任何东东
```

下来我们检查看窗口是否正常创建。如果成功， hWnd保存窗口的句柄。如果失败，弹出消息窗口，并退出程序。

```c
    {
        KillGLWindow();    // 重置显示区
        MessageBox(NULL,"不能创建一个窗口设备描述表","错误",MB_OK|MB_ICONEXCLAMATION);
        return FALSE;    // 返回 FALSE
    }
```

下面的代码描述象素格式。我们选择了通过RGBA(红、绿、蓝、alpha通道)支持OpenGL和双缓存的格式。我们试图找到匹配我们选定的色彩深度(16位、24位、32位)的象素格式。最后设置16位Z-缓存。其余的参数要么未使用要么不重要(stencil buffer模板缓存和accumulation buffer聚集缓存除外)。

```c
    static PIXELFORMATDESCRIPTOR pfd=   // /pfd 告诉窗口我们所希望的东东，即窗口使用的像素格式
    {
        sizeof(PIXELFORMATDESCRIPTOR),   // 上述格式描述符的大小
        1,    // 版本号
        PFD_DRAW_TO_WINDOW |   // 格式支持窗口
            PFD_SUPPORT_OPENGL |   // 格式必须支持OpenGL
            PFD_DOUBLEBUFFER,   // 必须支持双缓冲
        PFD_TYPE_RGBA,    // 申请 RGBA 格式
        bits,    // 选定色彩深度
        0, 0, 0, 0, 0, 0,   // 忽略的色彩位
        0,    // 无Alpha缓存
        0,    // 忽略Shift Bit
        0,    // 无累加缓存
        0, 0, 0, 0,    // 忽略聚集位
        16,    // 16位 Z-缓存 (深度缓存)
        0,    // 无蒙板缓存
        0,    // 无辅助缓存
        PFD_MAIN_PLANE,    // 主绘图层
        0,    // Reserved
        0, 0, 0    // 忽略层遮罩
    };
```

如果前面创建窗口时没有错误发生，我们接着尝试取得OpenGL设备描述表。若无法取得DC，弹出错误消息程序退出(返回FALSE)。

```c
    if (!(hDC=GetDC(hWnd)))    // 取得设备描述表了么?
    {
        KillGLWindow();    // 重置显示区
        MessageBox(NULL,"不能创建一种相匹配的像素格式","错误",MB_OK|MB_ICONEXCLAMATION);
        return FALSE;    // 返回 FALSE
    }
```

设法为OpenGL窗口取得设备描述表后，我们尝试找到对应与此前我们选定的象素格式的象素格式。如果Windows不能找到的话，弹出错误消息，并退出程序(返回FALSE)。

```c
    if (!(PixelFormat=ChoosePixelFormat(hDC,&pfd)))  // Windows 找到相应的象素格式了吗?
    {
        KillGLWindow();    // 重置显示区
        MessageBox(NULL,"不能设置像素格式","错误",MB_OK|MB_ICONEXCLAMATION);
        return FALSE;    // 返回 FALSE
    }
```

Windows 找到相应的象素格式后，尝试设置象素格式。如果无法设置，弹出错误消息，并退出程序(返回FALSE)。

```c
    if(!SetPixelFormat(hDC,PixelFormat,&pfd))  // 能够设置象素格式么?
    {
        KillGLWindow();    // 重置显示区
        MessageBox(NULL,"不能设置像素格式","错误",MB_OK|MB_ICONEXCLAMATION);
        return FALSE;    // 返回 FALSE
    }
```

正常设置象素格式后，尝试取得着色描述表。如果不能取得着色描述表的话，弹出错误消息，并退出程序(返回FALSE)。 

 

```c
    if (!(hRC=wglCreateContext(hDC)))   // 能否取得着色描述表?
    {
        KillGLWindow();    // 重置显示区
        MessageBox(NULL,"不能创建OpenGL渲染描述表","错误",MB_OK|MB_ICONEXCLAMATION);
        return FALSE;    // 返回 FALSE
    }
```

如果到现在仍未出现错误的话，我们已经设法取得了设备描述表和着色描述表。接着要做的是激活着色描述表。如果无法激活，弹出错误消息，并退出程序(返回FALSE)。

```c
    if(!wglMakeCurrent(hDC,hRC))   // 尝试激活着色描述表
    {
        KillGLWindow();    // 重置显示区
        MessageBox(NULL,"不能激活当前的OpenGL渲然描述表","错误",MB_OK|MB_ICONEXCLAMATION);
        return FALSE;    // 返回 FALSE
    }
```

一切顺利的话，OpenGL窗口已经创建完成，接着可以显示它啦。将它设为前端窗口(给它更高的优先级)，并将焦点移至此窗口。然后调用ReSizeGLScene 将屏幕的宽度和高度设置给透视OpenGL屏幕。

```c
    ShowWindow(hWnd,SW_SHOW);   // 显示窗口
    SetForegroundWindow(hWnd);   // 略略提高优先级
    SetFocus(hWnd);    // 设置键盘的焦点至此窗口
    ReSizeGLScene(width, height);   // 设置透视 GL 屏幕
```

跳转至 InitGL()，这里可以设置光照、纹理、等等任何需要设置的东东。您可以在 InitGL()内部自行定义错误检查，并返回 TRUE (一切正常)或FALSE (有什么不对)。例如，如果您在InitGL()内装载纹理并出现错误，您可能希望程序停止。如果您返回 FALSE的话，下面的代码会弹出错误消息，并退出程序。

```c
    if (!InitGL())    // 初始化新建的GL窗口
    {
        KillGLWindow();    // 重置显示区
        MessageBox(NULL,"Initialization Failed.","ERROR",MB_OK|MB_ICONEXCLAMATION);
        return FALSE;    // 返回 FALSE
    }
```

到这里可以安全的推定创建窗口已经成功了。我们向WinMain()返回TRUE，告知WinMain()没有错误，以防止程序退出。

```c
	return TRUE;    // 成功
}
```

下面的代码处理所有的窗口消息。当我们注册好窗口类之后，程序跳转到这部分代码处理窗口消息。

```c
LRESULT CALLBACK WndProc( HWND hWnd,   // 窗口的句柄
                         UINT uMsg,   // 窗口的消息
                         WPARAM wParam,   // 附加的消息内容
                         LPARAM lParam)   // 附加的消息内容
{
```

下面的代码比对uMsg的值，然后转入case处理，uMsg 中保存了我们要处理的消息名字。

```c
    switch (uMsg)    // 检查Windows消息
    {
```

如果uMsg等于WM_ACTIVE，查看窗口是否仍然处于激活状态。如果窗口已被最小化，将变量active设为FALSE。如果窗口已被激活，变量active的值为TRUE。

```c
        case WM_ACTIVATE:   // 监视窗口激活消息
        {
            if (!HIWORD(wParam))   // 检查最小化状态
            {
                active=TRUE;   // 程序处于激活状态
            }
            else
            {
                active=FALSE;   // 程序不再激活
            }

            return 0;   // 返回消息循环
        }
```

如果消息是WM_SYSCOMMAND(系统命令)，再次比对wParam。如果wParam 是 SC_SCREENSAVE 或 SC_MONITORPOWER的话，不是有屏幕保护要运行，就是显示器想进入节电模式。返回0可以阻止这两件事发生。

```c
        case WM_SYSCOMMAND:   // 系统中断命令
        {
            switch (wParam)   // 检查系统调用
            {
                case SC_SCREENSAVE:  // 屏保要运行?
                case SC_MONITORPOWER:  // 显示器要进入节电模式?
                    return 0;   // 阻止发生
            }
            break;    // 退出
        }
```

如果 uMsg是WM_CLOSE，窗口将被关闭。我们发出退出消息，主循环将被中断。变量done被设为TRUE，WinMain()的主循环中止，程序关闭。

```c
        case WM_CLOSE:    // 收到Close消息?
        {
            PostQuitMessage(0);   // 发出退出消息
            return 0;   // 返回
        }
```

如果键盘有键按下，通过读取wParam的信息可以找出键值。我将键盘数组keys[ ]相应的数组组成员的值设为TRUE。这样以后就可以查找key[ ]来得知什么键被按下。允许同时按下多个键。

```c
        case WM_KEYDOWN:   // 有键按下么?
        {
            keys[wParam] = TRUE;   // 如果是，设为TRUE
            return 0;   // 返回
        }
```

同样，如果键盘有键释放，通过读取wParam的信息可以找出键值。然后将键盘数组keys[ ]相应的数组组成员的值设为FALSE。这样查找key[ ]来得知什么键被按下，什么键被释放了。键盘上的每个键都可以用0-255之间的一个数来代表。举例来说，当我们按下40所代表的键时，keys[40]的值将被设为TRUE。放开的话，它就被设为FALSE。这也是key数组的原理。

```c
        case WM_KEYUP:    // 有键放开么?
        {
            keys[wParam] = FALSE;   // 如果是，设为FALSE
            return 0;   // 返回
        }
```

当调整窗口时，uMsg 最后等于消息WM_SIZE。读取lParam的LOWORD 和HIWORD可以得到窗口新的宽度和高度。将他们传递给ReSizeGLScene()，OpenGL场景将调整为新的宽度和高度。

```c
        case WM_SIZE:    // 调整OpenGL窗口大小
        {
            ReSizeGLScene(LOWORD(lParam),HIWORD(lParam)); // LoWord=Width,HiWord=Height
            return 0;   // 返回
        }
	}
```

其余无关的消息被传递给DefWindowProc，让Windows自行处理。

```c
    // 向 DefWindowProc传递所有未处理的消息。
    return DefWindowProc(hWnd,uMsg,wParam,lParam);
}
```

下面是我们的Windows程序的入口。将会调用窗口创建例程，处理窗口消息，并监视人机交互。

```c
int WINAPI WinMain( HINSTANCE hInstance,  // 当前窗口实例
                   HINSTANCE hPrevInstance,  // 前一个窗口实例
                   LPSTR lpCmdLine,  // 命令行参数
                   int nCmdShow)  // 窗口显示状态
{
```

我们设置两个变量。msg 用来检查是否有消息等待处理。done的初始值设为FALSE。这意味着我们的程序仍未完成运行。只要程序done保持FALSE，程序继续运行。一旦done的值改变为TRUE，程序退出。

```c
    MSG msg;    // Windowsx消息结构
    BOOL done=FALSE;    // 用来退出循环的Bool 变量
```

这段代码完全可选。程序弹出一个消息窗口，询问用户是否希望在全屏模式下运行。如果用户单击NO按钮，fullscreen变量从缺省的TRUE改变为FALSE，程序也改在窗口模式下运行。

```c
    // 提示用户选择运行模式
    if (MessageBox(NULL,"你想在全屏模式下运行么？", "设置全屏模式",MB_YESNO|MB_ICONQUESTION)==IDNO)
    {
        fullscreen=FALSE;   // FALSE为窗口模式
    }
```

接着创建OpenGL窗口。CreateGLWindow函数的参数依次为标题、宽度、高度、色彩深度，以及全屏标志。就这么简单！我很欣赏这段代码的简洁。如果未能创建成功，函数返回FALSE。程序立即退出。

```c
    // 创建OpenGL窗口
    if (!CreateGLWindow("NeHe's OpenGL程序框架",640,480,16,fullscreen))
    {
        return 0;    // 失败退出
    }
```

下面是循环的开始。只要done保持FALSE，循环一直进行。

```c
    while(!done)    // 保持循环直到 done=TRUE
    {
```

我们要做的第一件事是检查是否有消息在等待。使用PeekMessage()可以在不锁住我们的程序的前提下对消息进行检查。许多程序使用GetMessage()，也可以很好的工作。但使用GetMessage()，程序在收到paint消息或其他别的什么窗口消息之前不会做任何事。

```c
        if (PeekMessage(&msg,NULL,0,0,PM_REMOVE))  // 有消息在等待吗?
        {
```

下面的代码查看是否出现退出消息。如果当前的消息是由PostQuitMessage(0)引起的WM_QUIT，done变量被设为TRUE，程序将退出。

```c
            if (msg.message==WM_QUIT)  // 收到退出消息?
            {
                done=TRUE;   // 是，则done=TRUE
            }
            else    // 不是，处理窗口消息
            {
```

如果不是退出消息，我们翻译消息，然后发送消息，使得WndProc() 或 Windows能够处理他们。

```c
                TranslateMessage(&msg);  // 翻译消息
                DispatchMessage(&msg);  // 发送消息
            }
        }
        else    // 如果没有消息
        {
```

如果没有消息，绘制我们的OpenGL场景。代码的第一行查看窗口是否激活。如果按下ESC键，done变量被设为TRUE，程序将会退出。

```c
            // 绘制场景。监视ESC键和来自DrawGLScene()的退出消息
            if (active)   // 程序激活的么?
            {
                if (keys[VK_ESCAPE])  // ESC 按下了么?
                {
                    done=TRUE;  // ESC 发出退出信号
                }
                else   // 不是退出的时候，刷新屏幕
                {
```

如果程序是激活的且ESC没有按下，我们绘制场景并交换缓存(使用双缓存可以实现无闪烁的动画)。我们实际上在另一个看不见的"屏幕"上绘图。当我们交换缓存后，我们当前的屏幕被隐藏，现在看到的是刚才看不到的屏幕。这也是我们看不到场景绘制过程的原因。场景只是即时显示。 

```c
                    DrawGLScene();  // 绘制场景
                    SwapBuffers(hDC);  // 交换缓存 (双缓存)
                }
			}
```

下面的一点代码是最近新加的(05-01-00)。允许用户按下F1键在全屏模式和窗口模式间切换。

```c
            if (keys[VK_F1])   // F1键按下了么?
            {
                keys[VK_F1]=FALSE;  // 若是，使对应的Key数组中的值为 FALSE
                KillGLWindow();   // 销毁当前的窗口
                fullscreen=!fullscreen;  // 切换 全屏 / 窗口 模式
                // 重建 OpenGL 窗口
                if (!CreateGLWindow("NeHe's OpenGL 程序框架",640,480,16,fullscreen))
                {
                    return 0;  // 如果窗口未能创建，程序退出
                }
			}
		}
	}
```

如果done变量不再是FALSE，程序退出。正常销毁OpenGL窗口，将所有的内存释放，退出程序。

```c
    // 关闭程序
    KillGLWindow();    // 销毁窗口
    return (msg.wParam);    // 退出程序
}
```

在这一课中，我已试着尽量详细解释一切。每一步都与设置有关，并创建了一个全屏OpenGL程序。当您按下ESC键程序就会退出，并监视窗口是否激活。我花了整整2周时间来写代码，一周时间来改正BUG并讨论编程指南，2天(整整22小时来写HTML文件)。如果您有什么意见或建议请给我EMAIL。如果您认为有什么不对或可以改进，请告诉我。我想做最好的OpenGL教程并对您的反馈感兴趣。

版权与使用声明:
我是个对学习和生活充满激情的普通男孩,在网络上我以DancingWind为昵称，我的联系方式是zhouwei02@mails.tsinghua.edu.cn，如果你有任何问题，都可以联系我。
引子
网络是一个共享的资源，但我在自己的学习生涯中浪费大量的时间去搜索可用的资料，在现实生活中花费了大量的金钱和时间在书店中寻找资料，于是我给自己起了个昵称DancingWind，其意义是想风一样从各个知识的站点中吸取成长的养料。在飘荡了多年之后，我决定把自己收集的资料整理为一个统一的资源库。

版权声明
所有DancingWind发表的内容，大多都来自共享的资源，所以我没有资格把它们据为己有，或声称自己为这些资源作出了一点贡献。故任何人都可以复制，修改，重新发表，甚至以自己的名义发表，我都不会追究，但你在做以上事情的时候必须保证内容的完整性，给后来的人一个完整的教程。最后，任何人不能以这些资料的任何部分，谋取任何形式的报酬。

发展计划
在国外，很多资料都是很多人花费几年的时间慢慢积累起来的。如果任何人有兴趣与别人共享你的知识，我很欢迎你与我联系，但你必须同意我上面的声明。

感谢
感谢我的母亲一直以来对我的支持和在生活上的照顾。
感谢我深爱的女友田芹，一直以来默默的在精神上和生活中对我的支持，她甚至把买衣服的钱都用来给我买书了，她真的是我见过的最好的女孩，希望我能带给她幸福。

# 第二课 你的第一个多边形

在第一个教程的基础上，我们添加了一个三角形和一个四边形。也许你认为这很简单，但你已经迈出了一大步，要知道任何在OpenGL中绘制的模型都会被分解为这两种简单的图形。

读完了这一课，你会学到如何在空间放置模型，并且会知道深度缓存的概念。

第一课中，我教您如何创建一个OpenGL窗口。这一课中，我将教您如何创建三角形和四边形。我们讲使用来创建GL_TRIANGLES一个三角形，GL_QUADS来创建一个四边形。
在第一课代码的基础上，我们只需在DrawGLScene()过程中增加代码。下面我重写整个过程。如果您计划修改上节课的代码，只需用下面的代码覆盖原来的DrawGLScene()就可以了。

```c
int DrawGLScene(GLvoid)    // 此过程中包括所有的绘制代码
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // 清除屏幕及深度缓存
    glLoadIdentity();    // 重置当前的模型观察矩阵
```

当您调用glLoadIdentity()之后，您实际上将当前点移到了屏幕中心，X坐标轴从左至右，Y坐标轴从下至上，Z坐标轴从里至外。OpenGL屏幕中心的坐标值是X和Y轴上的0.0f点。中心左面的坐标值是负值，右面是正值。移向屏幕顶端是正值，移向屏幕底端是负值。移入屏幕深处是负值，移出屏幕则是正值。
glTranslatef(x, y, z)沿着 X, Y 和 Z 轴移动。根据前面的次序，下面的代码沿着X轴左移1.5个单位，Y轴不动(0.0f)，最后移入屏幕6.0f个单位。注意在glTranslatef(x, y, z)中当您移动的时候，您并不是相对屏幕中心移动，而是相对与当前所在的屏幕位置。

```c
	glTranslatef(-1.5f,0.0f,-6.0f);   // 左移 1.5 单位，并移入屏幕 6.0
```

现在我们已经移到了屏幕的左半部分，并且将视图推入屏幕背后足够的距离以便我们可以看见全部的场景－创建三角形。glBegin(GL_TRIANGLES)的意思是开始绘制三角形，glEnd() 告诉OpenGL三角形已经创建好了。通常您会需要画3个顶点，可以使用GL_TRIANGLES。在绝大多数的显卡上，绘制三角形是相当快速的。如果要画四个顶点，使用GL_QUADS的话会更方便。但据我所知，绝大多数的显卡都使用三角形来为对象着色。最后，如果您想要画更多的顶点时，可以使用GL_POLYGON。
本节的简单示例中，我们只画一个三角形。如果要画第二个三角形的话，可以在这三点之后，再加三行代码(3点)。所有六点代码都应包含在glBegin(GL_TRIANGLES) 和 glEnd()之间。在他们之间再不会有多余的点出现，也就是说，(GL_TRIANGLES) 和 glEnd()之间的点都是以三点为一个集合的。这同样适用于四边形。如果您知道实在绘制四边形的话，您必须在第一个四点之后，再加上四点为一个集合的点组。另一方面，多边形可以由任意个顶点，(GL_POLYGON)不在乎glBegin(GL_TRIANGLES) 和 glEnd()之间有多少行代码。

glBegin之后的第一行设置了多边形的第一个顶点，glVertex 的第一个参数是X坐标，然后依次是Y坐标和Z坐标。第一个点是上顶点，然后是左下顶点和右下顶点。glEnd()告诉OpenGL没有其他点了。这样将显示一个填充的三角形。

```c
    glBegin(GL_TRIANGLES);    // 绘制三角形
    glVertex3f( 0.0f, 1.0f, 0.0f);   // 上顶点
    glVertex3f(-1.0f,-1.0f, 0.0f);   // 左下
    glVertex3f( 1.0f,-1.0f, 0.0f);   // 右下
    glEnd();    // 三角形绘制结束
```

在屏幕的左半部分画完三角形后，我们要移到右半部分来画正方形。为此要再次使用glTranslate。这次右移，所以X坐标值为正值。因为前面左移了1.5个单位，这次要先向右移回屏幕中心(1.5个单位)，再向右移动1.5个单位。总共要向右移3.0个单位。 

```c
    glTranslatef(3.0f,0.0f,0.0f);   // 右移3单位
```

现在使用GL_QUADS绘制正方形。与绘制三角形的代码相类似，画四边形也很简单。唯一的区别是用GL_QUADS来替换了GL_TRIANGLES。并增加了一个点。我们使用顺时针次序来画正方形－左上－右上－右下－左下。采用顺时针绘制的是对象的后表面。这就是说我们所看见的是正方形的背面。逆时针画出来的正方形才是正面朝着我们的。现在这对您来说并不重要，但以后您必须知道。 

```c
    glBegin(GL_QUADS);    // 绘制正方形
    glVertex3f(-1.0f, 1.0f, 0.0f);   // 左上
    glVertex3f( 1.0f, 1.0f, 0.0f);   // 右上
    glVertex3f( 1.0f,-1.0f, 0.0f);   // 左下
    glVertex3f(-1.0f,-1.0f, 0.0f);   // 右下
    glEnd();    // 正方形绘制结束
    return TRUE;    // 继续运行
}
```

 最后换掉窗口模式下的标题内容。 

```c
if (keys[VK_F1])   // F1键按下了么?
{
    keys[VK_F1]=FALSE;  // 若是，使对应的Key数组中的值为 FALSE
    KillGLWindow();   // 销毁当前的窗口
    fullscreen=!fullscreen;  // 切换 全屏 / 窗口 模式
    // 重建 OpenGL 窗口(修改)
    if (!CreateGLWindow("NeHe's 第一个多边形程序",640,480,16,fullscreen))
    {
        return 0;  // 如果窗口未能创建，程序退出
    }
}
```


在这一课中，我已试着尽量详细的解释与多边形绘制有关的步骤。并创建了一个绘制三角形和正方形的OpenGL程序。如果您有什么意见或建议请给我EMAIL。如果您认为有什么不对或可以改进，请告诉我。我想做最好的OpenGL教程并对您的反馈感兴趣。

# 第三课 添加颜色

作为第二课的扩展，我将叫你如何使用颜色。你将理解两种着色模式，在左图中，三角形用的是光滑着色，四边形用的是平面着色。

上一课中我教给您三角形和四边形的绘制方法。这一课我将教您给三角形和四边形添加2种不同类型的着色方法。使用Flat coloring(单调着色)给四边形涂上固定的一种颜色。使用Smooth coloring(平滑着色)将三角形的三个顶点的不同颜色混合在一起，创建漂亮的色彩混合。
继续在上节课的DrawGLScene例程上修改。下面将整个例程重写了一遍。如果您计划修改上节课的代码，只需用下面的代码覆盖原来的DrawGLScene()就可以了。

```c
int DrawGLScene(GLvoid)    // 此过程中包括所有的绘制代码
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除屏幕及深度缓存
    glLoadIdentity();   // 重置模型观察矩阵
    glTranslatef(-1.5f,0.0f,-6.0f);   // 左移 1.5 单位，并移入屏幕 6.0

    glBegin(GL_TRIANGLES);   // 绘制三角形
```

如果您还记得上节课的内容，这段代码在屏幕的左半部分绘制三角形。下一行代码是我们第一次使用命令glColor3f(r,g,b)。括号中的三个参数依次是红、绿、蓝三色分量。取值范围可以从0,0f到1.0f。类似于以前所讲的清除屏幕背景命令。
我们将颜色设为红色(纯红色，无绿色，无蓝色)。接下来的一行代码设置三角形的第一个顶点(三角形的上顶点)，并使用当前颜色(红色)来绘制。从现在开始所有的绘制的对象的颜色都是红色，直到我们将红色改变成别的什么颜色。

```c
    glColor3f(1.0f,0.0f,0.0f);  // 设置当前色为红色
    glVertex3f( 0.0f, 1.0f, 0.0f);  // 上顶点
```

第一个红色顶点已经设置完毕。接下来我们设置第二个绿色顶点。三角形的左下顶点被设为绿色。 

```c
    glColor3f(0.0f,1.0f,0.0f);  // 设置当前色为绿色
    glVertex3f(-1.0f,-1.0f, 0.0f);  // 左下
```

现在设置第三个也就是最后一个顶点。开始绘制之前将颜色设为蓝色。这将是三角形的右下顶点。glEnd()出现后，三角形将被填充。但是因为每个顶点有不同的颜色，因此看起来颜色从每个角喷出，并刚好在三角形的中心汇合，三种颜色相互混合。这就是平滑着色。 

```c
    glColor3f(0.0f,0.0f,1.0f);  // 设置当前色为蓝色
    glVertex3f( 1.0f,-1.0f, 0.0f);  // 右下
    glEnd();    // 三角形绘制结束

    glTranslatef(3.0f,0.0f,0.0f);   // 右移3单位
```

现在我们绘制一个单调着色－蓝色的正方形。最重要的是要记住，设置当前色之后绘制的所有东东都是当前色的。以后您所创建的每个工程都要使用颜色。即便是在完全采用纹理贴图的时候，glColor3f仍旧可以用来调节纹理的色调。等等....,以后再说吧。
我们必须要做的事只需将颜色一次性的设为我们想采用的颜色(本例采用蓝色)，然后绘制场景。每个顶点都是蓝色的，因为我们没有告诉OpenGL要改变顶点的颜色。最后的结果是.....全蓝色的正方形。再说一遍，顺时针绘制的正方形意味着我们所看见的是四边形的背面。

```c
    glColor3f(0.5f,0.5f,1.0f);   // 一次性将当前色设置为蓝色
    glBegin(GL_QUADS);   // 绘制正方形
    glVertex3f(-1.0f, 1.0f, 0.0f);  // 左上
    glVertex3f( 1.0f, 1.0f, 0.0f);  // 右上
    glVertex3f( 1.0f,-1.0f, 0.0f);  // 左下
    glVertex3f(-1.0f,-1.0f, 0.0f);  // 右下
    glEnd();    // 正方形绘制结束
    return TRUE;    // 继续运行
}
```

最后换掉窗口模式下的标题内容 

```c
// 重建 OpenGL 窗口
if (!CreateGLWindow("NeHe's颜色实例",640,480,16,fullscreen))
```


在这一课中，我试着尽量详细的解释如何为您的OpenGL多边形添加单调和平滑的着色效果的步骤。改改代码中的红绿蓝分量值，看看最后y有什么样的结果。如果您有什么意见或建议请给我EMAIL。如果您认为有什么不对或可以改进，请告诉我。我想做最好的OpenGL教程并对您的反馈感兴趣。

# 第四课 旋转

在这一课里，我将教会你如何旋转三角形和四边形。左图中的三角形沿Y轴旋转，四边形沿着X轴旋转。
上一课中我教给您三角形和四边形的着色。这一课我将教您如何将这些彩色对象绕着坐标轴旋转。
其实只需在上节课的代码上增加几行就可以了。下面我将整个例程重写一遍。方便您知道增加了什么，修改了什么。
我们增加两个变量来控制这两个对象的旋转。这两个变量加在程序的开始处其他变量的后面( bool fullscreen=TRUE;下面的两行)。它们是浮点类型的变量，使得我们能够非常精确地旋转对象。浮点数包含小数位置，这意味着我们无需使用1、2、3...的角度。你会发现浮点数是OpenGL编程的基础。新变量中叫做 rtri 的用来旋转三角形， rquad 旋转四边形。 

```c
GLfloat rtri;   // 用于三角形的角度
GLfloat rquad;   // 用于四边形的角度
```

接着我们修改DrawGLScene()的代码。
下面这段代码与上一课的相同。 

```c
int DrawGLScene(GLvoid)   // 此过程中包括所有的绘制代码
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除屏幕及深度缓存
    glLoadIdentity();   // 重置模型观察矩阵
    glTranslatef(-1.5f,0.0f,-6.0f);  // 左移 1.5 单位，并移入屏幕 6.0
```

下一行代码是新的。glRotatef(Angle,Xvector,Yvector,Zvector)负责让对象绕某个轴旋转。这个命令有很多用处。 Angle 通常是个变量代表对象转过的角度。 Xvector , Yvector 和 Zvector 三个参数则共同决定旋转轴的方向。比如(1,0,0)所描述的矢量经过X坐标轴的1个单位处并且方向向右。(-1,0,0)所描述的矢量经过X坐标轴的1个单位处，但方向向左。
D. Michael Traub:提供了对 Xvector , Yvector 和 Zvector 的上述解释。
为了更好的理解X, Y 和 Z的旋转，我举些例子...
X轴－您正在使用一台台锯。锯片中心的轴从左至右摆放(就像OpenGL中的X轴)。尖利的锯齿绕着X轴狂转，看起来要么向上转，要么向下转。取决于锯片开始转时的方向。这与我们在OpenGL中绕着X轴旋转什么的情形是一样的。(译者注：这会儿您要把脸蛋凑向显示器的话，保准被锯开了花 ^-^。)

Y轴－假设您正处于一个巨大的龙卷风中心，龙卷风的中心从地面指向天空(就像OpenGL中的Y轴)。垃圾和碎片围着Y轴从左向右或是从右向左狂转不止。这与我们在OpenGL中绕着Y轴旋转什么的情形是一样的。

Z轴－您从正前方看着一台风扇。风扇的中心正好朝着您(就像OpenGL中的Z轴)。风扇的叶片绕着Z轴顺时针或逆时针狂转。这与我们在OpenGL中绕着Z轴旋转什么的情形是一样的。

下面的一行代码中，如果rtri等于7，我们将三角形绕着Y轴从左向右旋转7 。您也可以改变参数的值，让三角形绕着X和Y轴同时旋转。

```c
    glRotatef(rtri,0.0f,1.0f,0.0f);  // 绕Y轴旋转三角形
```

 下面的代码没有变化。在屏幕的左面画了一个彩色渐变三角形，并绕着Y轴从左向右旋转。 

```c
    glBegin(GL_TRIANGLES);   // 绘制三角形
    glColor3f(1.0f,0.0f,0.0f);  // 设置当前色为红色
    glVertex3f( 0.0f, 1.0f, 0.0f);  // 上顶点
    glColor3f(0.0f,1.0f,0.0f);  // 设置当前色为绿色
    glVertex3f(-1.0f,-1.0f, 0.0f);  // 左下
    glColor3f(0.0f,0.0f,1.0f);  // 设置当前色为蓝色
    glVertex3f( 1.0f,-1.0f, 0.0f);  // 右下
    glEnd();   // 三角形绘制结束
```

您会注意下面的代码中我们增加了另一个glLoadIdentity()调用。目的是为了重置模型观察矩阵。如果我们没有重置，直接调用glTranslate的话，会出现意料之外的结果。因为坐标轴已经旋转了，很可能没有朝着您所希望的方向。所以我们本来想要左右移动对象的，就可能变成上下移动了，取决于您将坐标轴旋转了多少角度。试试将glLoadIdentity() 注释掉之后，会出现什么结果。
重置模型观察矩阵之后，X，Y，Z轴都以复位，我们调用glTranslate。您会注意到这次我们只向右一了1.5单位，而不是上节课的3.0单位。因为我们重置场景的时候，焦点又回到了场景的中心(0.0处)。这样就只需向右移1.5单位就够了。
当我们移到新位置后，绕X轴旋转四边形。正方形将上下转动。

```c
    glLoadIdentity();   // 重置模型观察矩阵
    glTranslatef(1.5f,0.0f,-6.0f);  // 右移1.5单位,并移入屏幕 6.0
    glRotatef(rquad,1.0f,0.0f,0.0f);  // 绕X轴旋转四边形
```

下一段代码保持不变。在屏幕的右侧画一个蓝色的正方形 

```c
    glColor3f(0.5f,0.5f,1.0f);  // 一次性将当前色设置为蓝色
    glBegin(GL_QUADS);   // 绘制正方形
    glVertex3f(-1.0f, 1.0f, 0.0f);  // 左上
    glVertex3f( 1.0f, 1.0f, 0.0f);  // 右上
    glVertex3f( 1.0f,-1.0f, 0.0f);  // 左下
    glVertex3f(-1.0f,-1.0f, 0.0f);  // 右下
    glEnd();   // 正方形绘制结束
```

下两行是新增的。倘若把 rtri 和 rquad 想象为容器，那么在程序的开始我们创建了容器( GLfloat rtri , 和 GLfloat rquad )。当容器创建之后，里面是空的。下面的第一行代码是向容器中添加0.2。因此每次当我们运行完前面的代码后，都会在这里使 rtri 容器中的值增长0.2。后面一行将 rquad 容器中的值减少0.15。同样每次当我们运行完前面的代码后，都会在这里使 rquad 容器中的值下跌0.15。下跌最终会导致对象旋转的方向和增长的方向相反。
尝试改变下面代码中的+和-，来体会对象旋转的方向是如何改变的。并试着将0.2改成1.0。这个数字越大，物体就转的越快，这个数字越小，物体转的就越慢。

```c
    rtri+=0.2f;   // 增加三角形的旋转变量
    rquad-=0.15f;   // 减少四边形的旋转变量
    return TRUE;   // 继续运行
}
```

最后换掉窗口模式下的标题内容 

```c
// 重建 OpenGL 窗口
if (!CreateGLWindow("NeHe's 旋转实例",640,480,16,fullscreen))
```

在这一课中，我试着尽量详细的解释如何让对象绕某个轴转动。改改代码，试着让对象绕着Z轴、X+Y轴或者所有三个轴来转动:)。如果您有什么意见或建议请给我EMAIL。如果您认为有什么不对或可以改进，请告诉我。我想做最好的OpenGL教程并对您的反馈感兴趣。

# 第五课 3D空间

我们使用多边形和四边形创建3D物体，在这一课里，我们把三角形变为立体的金子塔形状，把四边形变为立方体。

在上节课的内容上作些扩展，我们现在开始生成真正的3D对象，而不是象前两节课中那样3D世界中的2D对象。我们给三角形增加一个左侧面，一个右侧面，一个后侧面来生成一个金字塔(四棱锥)。给正方形增加左、右、上、下及背面生成一个立方体。
我们混合金字塔上的颜色，创建一个平滑着色的对象。给立方体的每一面则来个不同的颜色。

```c
int DrawGLScene(GLvoid)   // 此过程中包括所有的绘制代码
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除屏幕及深度缓存
    glLoadIdentity();   // 重置模型观察矩阵
    glTranslatef(-1.5f,0.0f,-6.0f);  // 左移 1.5 单位，并移入屏幕 6.0

    glRotatef(rtri,0.0f,1.0f,0.0f);  // 绕Y轴旋转金字塔

    glBegin(GL_TRIANGLES);   // 开始绘制金字塔的各个面
```

有些人可能早已在上节课中的代码上尝试自行创建3D对象了。但经常有人来信问我:"我的对象怎么不会绕着其自身的轴旋转？看起来总是在满屏乱转。"要让您的对象绕自身的轴旋转，您必须让对象的中心坐标总是(0.0f,0,0f,0,0f)。
下面的代码创建一个绕者其中心轴旋转的金字塔。金字塔的上顶点高出原点一个单位，底面中心低于原点一个单位。上顶点在底面的投影位于底面的中心。
注意所有的面－三角形都是逆时针次序绘制的。这点十分重要，在以后的课程中我会作出解释。现在，您只需明白要么都逆时针，要么都顺时针，但永远不要将两种次序混在一起，除非您有足够的理由必须这么做。

我们开始画金字塔的前侧面。因为所有的面都共享上顶点，我们将这点在所有的三角形中都设置为红色。底边上的两个顶点的颜色则是互斥的。前侧面的左下顶点是绿色的，右下顶点是蓝色的。这样相邻右侧面的左下顶点是蓝色的，右下顶点是绿色的。这样四边形的底面上的点的颜色都是间隔排列的。

```c
    glColor3f(1.0f,0.0f,0.0f);  // 红色
    glVertex3f( 0.0f, 1.0f, 0.0f);  // 三角形的上顶点 (前侧面)
    glColor3f(0.0f,1.0f,0.0f);  // 绿色
    glVertex3f(-1.0f,-1.0f, 1.0f);  // 三角形的左下顶点 (前侧面)
    glColor3f(0.0f,0.0f,1.0f);  // 蓝色
    glVertex3f( 1.0f,-1.0f, 1.0f);  // 三角形的右下顶点 (前侧面)
```

现在绘制右侧面。注意其底边上的两个顶点的X坐标位于中心右侧的一个单位处。顶点则位于Y轴上的一单位处，且Z坐标正好处于底边的两顶点的Z坐标中心。右侧面从上顶点开始向外侧倾斜至底边上。
这次的左下顶点用蓝色绘制，以保持与前侧面的右下顶点的一致。蓝色将从这个角向金字塔的前侧面和右侧面扩展并与其他颜色混合。
还应注意到后面的三个侧面和前侧面处于同一个glBegin(GL_TRIANGLES) 和 glEnd()语句中间。因为我们是通过三角形来构造这个金字塔的。OpenGL知道每三个点构成一个三角形。当它画完一个三角形之后，如果还有余下的点出现，它就以为新的三角形要开始绘制了。OpenGL在这里并不会将四点画成一个四边形，而是假定新的三角形开始了。所以千万不要无意中增加任何多余的点。 

```c
    glColor3f(1.0f,0.0f,0.0f);  // 红色
    glVertex3f( 0.0f, 1.0f, 0.0f);  // 三角形的上顶点 (右侧面)
    glColor3f(0.0f,0.0f,1.0f);  // 蓝色
    glVertex3f( 1.0f,-1.0f, 1.0f);  // 三角形的左下顶点 (右侧面)
    glColor3f(0.0f,1.0f,0.0f);  // 绿色
    glVertex3f( 1.0f,-1.0f, -1.0f);  // 三角形的右下顶点 (右侧面)
```

现在是后侧面。再次切换颜色。左下顶点又回到绿色，因为后侧面与右侧面共享这个角。 

```c
    glColor3f(1.0f,0.0f,0.0f);  // 红色
    glVertex3f( 0.0f, 1.0f, 0.0f);  // 三角形的上顶点 (后侧面)
    glColor3f(0.0f,1.0f,0.0f);  // 绿色
    glVertex3f( 1.0f,-1.0f, -1.0f);  // 三角形的左下顶点 (后侧面)
    glColor3f(0.0f,0.0f,1.0f);  // 蓝色
    glVertex3f(-1.0f,-1.0f, -1.0f);  // 三角形的右下顶点 (后侧面)
```

最后画左侧面。又要切换颜色。左下顶点是蓝色，与后侧面的右下顶点相同。右下顶点是蓝色，与前侧面的左下顶点相同。
到这里金字塔就画完了。因为金字塔只绕着Y轴旋转，我们永远都看不见底面，因而没有必要添加底面。如果您觉得有经验了，尝试增加底面(正方形)，并将金字塔绕X轴旋转来看看您是否作对了。确保底面四个顶点的颜色与侧面的颜色相匹配。 

```c
    glColor3f(1.0f,0.0f,0.0f);  // 红色
    glVertex3f( 0.0f, 1.0f, 0.0f);  // 三角形的上顶点 (左侧面)
    glColor3f(0.0f,0.0f,1.0f);  // 蓝色
    glVertex3f(-1.0f,-1.0f,-1.0f);  // 三角形的左下顶点 (左侧面)
    glColor3f(0.0f,1.0f,0.0f);  // 绿色
    glVertex3f(-1.0f,-1.0f, 1.0f);  // 三角形的右下顶点 (左侧面)
    glEnd();   // 金字塔绘制结束
```

接下来开始画立方体。他由六个四边形组成。所有的四边形都以逆时针次序绘制。就是说先画右上角，然后左上角、左下角、最后右下角。您也许认为画立方体的背面的时候这个次序看起来好像顺时针，但别忘了我们从立方体的背后看背面的时候，与您现在所想的正好相反。(译者注：您是从立方体的外面来观察立方体的)。
注意到这次我们将立方体移地更远离屏幕了。因为立方体的大小要比金字塔大，同样移入6个单位时，立方体看起来要大的多。这是透视的缘故。越远的对象看起来越小 :) 。 

```c
    glLoadIdentity();
    glTranslatef(1.5f,0.0f,-7.0f);  // 先右移再移入屏幕

    glRotatef(rquad,1.0f,1.0f,1.0f);  // 在XYZ轴上旋转立方体

    glBegin(GL_QUADS);   // 开始绘制立方体
```

先画立方体的顶面。从中心上移一单位，注意Y坐标始终为一单位，表示这个四边形与Z轴平行。先画右上顶点，向右一单位，再屏幕向里一单位。然后左上顶点，向左一单位，再屏幕向里一单位。然后是靠近观察者的左下和右下顶点。就是屏幕往外一单位。 

```c
    glColor3f(0.0f,1.0f,0.0f);  // 颜色改为蓝色
    glVertex3f( 1.0f, 1.0f,-1.0f);  // 四边形的右上顶点 (顶面)
    glVertex3f(-1.0f, 1.0f,-1.0f);  // 四边形的左上顶点 (顶面)
    glVertex3f(-1.0f, 1.0f, 1.0f);  // 四边形的左下顶点 (顶面)
    glVertex3f( 1.0f, 1.0f, 1.0f);  // 四边形的右下顶点 (顶面)
```

底面的画法和顶面十分类似。只是Y坐标变成了－1。如果我们从立方体的下面来看立方体的话，您会注意到右上角离观察者最近，因此我们先画离观察者最近的顶点。然后是左上顶点最后才是屏幕里面的左下和右下顶点。
如果您真的不在乎绘制多边形的次序(顺时针或者逆时针)的话，您可以直接拷贝顶面的代码，将Y坐标从1改成 -1，也能够工作。但一旦您进入象纹理映射这样的领域时，忽略绘制次序会导致十分怪异的结果。

```c
    glColor3f(1.0f,0.5f,0.0f);  // 颜色改成橙色
    glVertex3f( 1.0f,-1.0f, 1.0f);  // 四边形的右上顶点(底面)
    glVertex3f(-1.0f,-1.0f, 1.0f);  // 四边形的左上顶点(底面)
    glVertex3f(-1.0f,-1.0f,-1.0f);  // 四边形的左下顶点(底面)
    glVertex3f( 1.0f,-1.0f,-1.0f);  // 四边形的右下顶点(底面)
```

接着画立方体的前面。保持Z坐标为一单位，前面正对着我们。 

```c
    glColor3f(1.0f,0.0f,0.0f);  // 颜色改成红色
    glVertex3f( 1.0f, 1.0f, 1.0f);  // 四边形的右上顶点(前面)
    glVertex3f(-1.0f, 1.0f, 1.0f);  // 四边形的左上顶点(前面)
    glVertex3f(-1.0f,-1.0f, 1.0f);  // 四边形的左下顶点(前面)
    glVertex3f( 1.0f,-1.0f, 1.0f);  // 四边形的右下顶点(前面)
```

立方体后面的绘制方法与前面类似。只是位于屏幕的里面。注意Z坐标现在保持 -1 不变。 

```c
    glColor3f(1.0f,1.0f,0.0f);  // 颜色改成黄色
    glVertex3f( 1.0f,-1.0f,-1.0f);  // 四边形的右上顶点(后面)
    glVertex3f(-1.0f,-1.0f,-1.0f);  // 四边形的左上顶点(后面)
    glVertex3f(-1.0f, 1.0f,-1.0f);  // 四边形的左下顶点(后面)
    glVertex3f( 1.0f, 1.0f,-1.0f);  // 四边形的右下顶点(后面)
```

还剩两个面就完成了。您会注意到总有一个坐标保持不变。这一次换成了X坐标。因为我们在画左侧面。 

```c
    glColor3f(0.0f,0.0f,1.0f);  // 颜色改成蓝色
    glVertex3f(-1.0f, 1.0f, 1.0f);  // 四边形的右上顶点(左面)
    glVertex3f(-1.0f, 1.0f,-1.0f);  // 四边形的左上顶点(左面)
    glVertex3f(-1.0f,-1.0f,-1.0f);  // 四边形的左下顶点(左面)
    glVertex3f(-1.0f,-1.0f, 1.0f);  // 四边形的右下顶点(左面)
```

立方体的最后一个面了。X坐标保持为一单位。逆时针绘制。您愿意的话，留着这个面不画也可以，这样就是一个盒子:)
或者您要是有兴趣可以改变立方体所有顶点的色彩值，象金字塔那样混合颜色。您会看见一个非常漂亮的彩色立方体，各种颜色在它的各个表面流淌。

```c
    glColor3f(1.0f,0.0f,1.0f);  // 颜色改成紫罗兰色
    glVertex3f( 1.0f, 1.0f,-1.0f);  // 四边形的右上顶点(右面)
    glVertex3f( 1.0f, 1.0f, 1.0f);  // 四边形的左上顶点(右面)
    glVertex3f( 1.0f,-1.0f, 1.0f);  // 四边形的左下顶点(右面)
    glVertex3f( 1.0f,-1.0f,-1.0f);  // 四边形的右下顶点(右面)
    glEnd();   // 立方体绘制结束

    rtri+=0.2f;   // 增加三角形的旋转变量
    rquad-=0.15f;   // 减少四边形的旋转变量
    return TRUE;   // 继续运行
}
```

这一课又结束了。到这里您应该已经较好的掌握了在3D空间创建对象的方法。必须将OpenGL屏幕想象成一张很大的画纸，后面还带着许多透明的层。差不多就是个由大量的点组成的立方体。这些点从左至右、从上至下、从前到后的布满了这个立方体。如果您能想象的出在屏幕的深度方向，应该在设计新3D对象时没有任何问题。
如果您对3D空间的理解很困难的话，千万不要灰心! 刚开始的时候，领会这些内容会很难。象立方体这样的对象是您练习的好例子。继续努力吧！如果您有什么意见或建议请给我EMAIL。如果您认为有什么不对或可以改进，请告诉我。我想做最好的OpenGL教程并对您的反馈感兴趣。

# 第六课 纹理映射

在这一课里，我将教会你如何把纹理映射到立方体的六个面。

学习 texture map 纹理映射(贴图)有很多好处。比方说您想让一颗导弹飞过屏幕。根据前几课的知识，我们最可行的办法可能是很多个多边形来构建导弹的轮廓并加上有趣的颜色。使用纹理映射，您可以使用真实的导弹图像并让它飞过屏幕。您觉得哪个更好看？照片还是一大堆三角形和四边形？使用纹理映射的好处还不止是更好看，而且您的程序运行会更快。导弹贴图可能只是一个飞过窗口的四边形。一个由多边形构建而来的导弹却很可能包括成百上千的多边形。很显然，贴图极大的节省了CPU时间。
现在我们在第一课的代码开始处增加五行新代码。新增的第一行是 #include <stdio.h> 。它允许我们对文件进行操作，为了在后面的代码中使用 fopen() ，我们增加了这一行。然后我们增加了三个新的浮点变量... xrot , yrot 和 zrot 。这些变量用来使立方体绕X、Y、Z轴旋转。最后一行 GLuint texture[1] 为一个纹理分配存储空间。如果您需要不止一个的纹理，应该将参数1改成您所需要的参数。 

```c
#include <stdio.h>    // 标准输入/输出库的头文件
#include <glaux.h>    // GLaux库的头文件

GLfloat xrot;    // X 旋转量
GLfloat yrot;    // Y 旋转量
GLfloat zrot;    // Z 旋转量

GLuint texture[1];    // 存储一个纹理
```

紧跟上面的代码在 ReSizeGLScene() 之前，我们增加了下面这一段代码。这段代码用来加载位图文件。如果文件不存在，返回 NULL 告知程序无法加载位图。在我开始解释这段代码之前，关于用作纹理的图像我想有几点十分重要，并且您必须明白。此图像的宽和高必须是2的n次方；宽度和高度最小必须是64象素；并且出于兼容性的原因，图像的宽度和高度不应超过256象素。如果您的原始素材的宽度和高度不是64,128,256象素的话，使用图像处理软件重新改变图像的大小。可以肯定有办法能绕过这些限制，但现在我们只需要用标准的纹理尺寸。
首先，我们创建一个文件句柄。句柄是个用来鉴别资源的数值，它使程序能够访问此资源。我们开始先将句柄设为 NULL 。

```c
AUX_RGBImageRec *LoadBMP(char *Filename)   // 载入位图图象
{
    FILE *File=NULL;    // 文件句柄
```

接下来检查文件名是否已提供。因为 LoadBMP() 可以无参数调用，所以我们不得不检查一下。您可不想什么都没载入吧.....:) 

```c
    if (!Filename)    // 确保文件名已提供
    {
        return NULL;    // 如果没提供，返回 NULL
    }
```

接着检查文件是否存在。下面这一行尝试打开文件。 

```c
    File=fopen(Filename,"r");   // 尝试打开文件
```

如果我们能打开文件的话，很显然文件是存在的。使用 fclose(File) 关闭文件。 auxDIBImageLoad(Filename) 读取图象数据并将其返回。 

```c
    if (File)    // 文件存在么?
    {
        fclose(File);    // 关闭句柄
        return auxDIBImageLoad(Filename);  // 载入位图并返回指针
    }
```

如果我们不能打开文件，我们将返回NULL。这意味着文件无法载入。程序在后面将检查文件是否已载入。如果没有，我们将退出程序并弹出错误消息。 

```c
    return NULL;    // 如果载入失败，返回 NULL
}
```

下一部分代码载入位图(调用上面的代码)并转换成纹理。 

```c
int LoadGLTextures()    // 载入位图(调用上面的代码)并转换成纹理
{
```

然后设置一个叫做 Status 的变量。我们使用它来跟踪是否能够载入位图以及能否创建纹理。 Status 缺省设为 FALSE (表示没有载入或创建任何东东)。 

```c
	int Status=FALSE;    // 状态指示器
```

现在我们创建存储位图的图像记录。次记录包含位图的宽度、高度和数据。 

```c
    AUX_RGBImageRec *TextureImage[1];   // 创建纹理的存储空间
```

清除图像记录，确保其内容为空 

```c
    memset(TextureImage,0,sizeof(void *)*1);  // 将指针设为 NULL
```

现在载入位图，并将其转换为纹理。 TextureImage[0]=LoadBMP("Data/NeHe.bmp") 调用 LoadBMP() 的代码。载入 Data 目录下的 NeHe.bmp 位图文件。如果一切正常，图像数据将存放在 TextureImage[0] 中， Status 被设为 TRUE ，然后我们开始创建纹理。 

```c
    // 载入位图，检查有无错误，如果位图没找到则退出
    if (TextureImage[0]=LoadBMP("Data/NeHe.bmp"))
    {
        Status=TRUE;    // 将 Status 设为 TRUE
```

现在使用中 TextureImage[0] 的数据创建纹理。第一行 glGenTextures(1, &texture[0]) 告诉OpenGL我们想生成一个纹理名字(如果您想载入多个纹理，加大数字)。值得注意的是，开始我们使用 GLuint texture[1] 来创建一个纹理的存储空间，您也许会认为第一个纹理就是存放在 &texture[1] 中的，但这是错的。正确的地址应该是 &texture[0] 。同样如果使用 GLuint texture[2] 的话，第二个纹理存放在 texture[1] 中。『译者注：学C的，在这里应该没有障碍，数组就是从零开始的嘛。』
第二行 glBindTexture(GL_TEXTURE_2D, texture[0]) 告诉OpenGL将纹理名字 texture[0] 绑定到纹理目标上。2D纹理只有高度(在 Y 轴上)和宽度(在 X 轴上)。主函数将纹理名字指派给纹理数据。本例中我们告知OpenGL， &texture[0] 处的内存已经可用。我们创建的纹理将存储在 &texture[0] 的 指向的内存区域。

```c
        glGenTextures(1, &texture[0]);   // 创建纹理
        // 使用来自位图数据生成 的典型纹理
        glBindTexture(GL_TEXTURE_2D, texture[0]);
```

下来我们创建真正的纹理。下面一行告诉OpenGL此纹理是一个2D纹理 ( GL_TEXTURE_2D )。参数“0”代表图像的详细程度，通常就由它为零去了。参数三是数据的成分数。因为图像是由红色数据，绿色数据，蓝色数据三种组分组成。 TextureImage[0]->sizeX 是纹理的宽度。如果您知道宽度，您可以在这里填入，但计算机可以很容易的为您指出此值。 TextureImage[0]->sizey 是纹理的高度。参数零是边框的值，一般就是“0”。 GL_RGB 告诉OpenGL图像数据由红、绿、蓝三色数据组成。
GL_UNSIGNED_BYTE 意味着组成图像的数据是无符号字节类型的。最后... TextureImage[0]->data 告诉OpenGL纹理数据的来源。此例中指向存放在 TextureImage[0] 记录中的数据。 

```c
        // 生成纹理
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data);
```

下面的两行告诉OpenGL在显示图像时，当它比放大得原始的纹理大 ( GL_TEXTURE_MAG_FILTER )或缩小得比原始得纹理小( GL_TEXTURE_MIN_FILTER )时OpenGL采用的滤波方式。通常这两种情况下我都采用 GL_LINEAR 。这使得纹理从很远处到离屏幕很近时都平滑显示。使用 GL_LINEAR 需要CPU和显卡做更多的运算。如果您的机器很慢，您也许应该采用 GL_NEAREST 。过滤的纹理在放大的时候，看起来斑驳的很『译者注：马赛克啦』。您也可以结合这两种滤波方式。在近处时使用 GL_LINEAR ，远处时 GL_NEAREST 。 

```c
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); // 线形滤波
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); // 线形滤波
    }
```

现在我们释放前面用来存放位图数据的内存。我们先查看位图数据是否存放在处。如果是的话，再查看数据是否已经存储。如果已经存储的话，删了它。接着再释放 TextureImage[0] 图像结构以保证所有的内存都能释放。 

```c
    if (TextureImage[0])    // 纹理是否存在
    {
        if (TextureImage[0]->data)   // 纹理图像是否存在
        {
            free(TextureImage[0]->data);  // 释放纹理图像占用的内存
        }

        free(TextureImage[0]);   // 释放图像结构
    }
```


最后返回状态变量。如果一切OK，变量 Status 的值为 TRUE 。否则为 FALSE 。 

```c
    return Status;    // 返回 Status
}
```

我只在 InitGL 中增加很少的几行代码。但为了方便您查看增加了哪几行，我这段代码全部重贴一遍。 if (!LoadGLTextures()) 这行代码调用上面讲的子例程载入位图并生成纹理。如果因为任何原因 LoadGLTextures() 调用失败，接着的一行返回FALSE。如果一切OK，并且纹理创建好了，我们启用2D纹理映射。如果您忘记启用的话，您的对象看起来永远都是纯白色，这一定不是什么好事。 

```c
int InitGL(GLvoid)    // 此处开始对OpenGL进行所有设置
{
    if (!LoadGLTextures())    // 调用纹理载入子例程
    {
        return FALSE;    // 如果未能载入，返回FALSE
    }

    glEnable(GL_TEXTURE_2D);   // 启用纹理映射
    glShadeModel(GL_SMOOTH);   // 启用阴影平滑
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);   // 黑色背景
    glClearDepth(1.0f);    // 设置深度缓存
    glEnable(GL_DEPTH_TEST);   // 启用深度测试
    glDepthFunc(GL_LEQUAL);    // 所作深度测试的类型
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);  // 真正精细的透视修正
    return TRUE;    // 初始化 OK
}
```

现在我们绘制贴图『译者注：其实贴图就是纹理映射。将术语换来换去不好，我想少打俩字。^_^』过的立方体。这段代码被狂注释了一把，应该很好懂。开始两行代码 glClear() 和 glLoadIdentity() 是第一课中就有的代码。 glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) 清除屏幕并设为我们在 InitGL() 中选定的颜色，本例中是黑色。深度缓存也被清除。模型观察矩阵也使用glLoadIdentity()重置。 

```c
int DrawGLScene(GLvoid)    // 从这里开始进行所有的绘制
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // 清除屏幕和深度缓存
    glLoadIdentity();    // 重置当前的模型观察矩阵
    glTranslatef(0.0f,0.0f,-5.0f);   // 移入屏幕 5 个单位
```

下面三行使立方体绕X、Y、Z轴旋转。旋转多少依赖于变量 xrot ， yrot 和 zrot 的值。 

```c
    glRotatef(xrot,1.0f,0.0f,0.0f);   // 绕X轴旋转
    glRotatef(yrot,0.0f,1.0f,0.0f);   // 绕Y轴旋转
    glRotatef(zrot,0.0f,0.0f,1.0f);   // 绕Z轴旋转
```

下一行代码选择我们使用的纹理。如果您在您的场景中使用多个纹理，您应该使用来 glBindTexture(GL_TEXTURE_2D, texture[ 所使用纹理对应的数字 ]) 选择要绑定的纹理。当您想改变纹理时，应该绑定新的纹理。有一点值得指出的是，您不能在 glBegin() 和 glEnd() 之间绑定纹理，必须在 glBegin() 之前或 glEnd() 之后绑定。注意我们在后面是如何使用 glBindTexture 来指定和绑定纹理的。 

```c
    glBindTexture(GL_TEXTURE_2D, texture[0]);  // 选择纹理
```

为了将纹理正确的映射到四边形上，您必须将纹理的右上角映射到四边形的右上角，纹理的左上角映射到四边形的左上角，纹理的右下角映射到四边形的右下角，纹理的左下角映射到四边形的左下角。如果映射错误的话，图像显示时可能上下颠倒，侧向一边或者什么都不是。
glTexCoord2f 的第一个参数是X坐标。 0.0f 是纹理的左侧。 0.5f 是纹理的中点， 1.0f 是纹理的右侧。 glTexCoord2f 的第二个参数是Y坐标。 0.0f 是纹理的底部。 0.5f 是纹理的中点， 1.0f 是纹理的顶部。

所以纹理的左上坐标是 X：0.0f，Y：1.0f ，四边形的左上顶点是 X： -1.0f，Y：1.0f 。其余三点依此类推。

试着玩玩 glTexCoord2f 的X，Y坐标参数。把 1.0f 改为 0.5f 将只显示纹理的左半部分，把 0.0f 改为 0.5f 将只显示纹理的右半部分。

```c
    glBegin(GL_QUADS);
    // 前面
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // 纹理和四边形的左下
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // 纹理和四边形的右下
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); // 纹理和四边形的右上
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // 纹理和四边形的左上
    // 后面
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); // 纹理和四边形的右下
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); // 纹理和四边形的右上
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // 纹理和四边形的左上
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // 纹理和四边形的左下
    // 顶面
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); // 纹理和四边形的左上
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // 纹理和四边形的左下
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, 1.0f, 1.0f); // 纹理和四边形的右下
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // 纹理和四边形的右上
    // 底面
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f); // 纹理和四边形的右上
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // 纹理和四边形的左上
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // 纹理和四边形的左下
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // 纹理和四边形的右下
    // 右面
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); // 纹理和四边形的右下
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); // 纹理和四边形的右上
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); // 纹理和四边形的左上
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); // 纹理和四边形的左下
    // 左面
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); // 纹理和四边形的左下
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); // 纹理和四边形的右下
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); // 纹理和四边形的右上
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); // 纹理和四边形的左上
    glEnd();
```

现在增加 xrot , yrot 和 zrot 的值。尝试变化每次各变量的改变值来调节立方体的旋转速度，或改变+/-号来调节立方体的旋转方向。 

```c
    xrot+=0.3f;    // X 轴旋转
    yrot+=0.2f;    // Y 轴旋转
    zrot+=0.4f;    // Z 轴旋转
    return true;    // 继续运行
}
```


现在您应该比较好的理解纹理映射(贴图)了。您应该掌握了给任意四边形表面贴上您所喜爱的图像的技术。一旦您对2D纹理映射的理解感到自信的时候，试试给立方体的六个面贴上不同的纹理。
当您理解纹理坐标的概念后，纹理映射并不难理解。！如果您有什么意见或建议请给我EMAIL。如果您认为有什么不对或可以改进，请告诉我。

# 第七课 光照和键盘控制

在这一课里，我们将添加光照和键盘控制，它让程序看起来更美观。

这一课我会教您如何使用三种不同的纹理滤波方式。教您如何使用键盘来移动场景中的对象，还会教您在OpenGL场景中应用简单的光照。这一课包含了很多内容，如果您对前面的课程有疑问的话，先回头复习一下。进入后面的代码之前，很好的理解基础知识十分重要。
我们还是在第一课的代码上加以修改。跟以前不一样的是，只要有任何大的改动，我都会写出整段代码。程序开始，我们先加上几个新的变量。 
下面几行是新的。我们增加三个布尔变量。 light 变量跟踪光照是否打开。变量lp和fp用来存储'L' 和'F'键是否按下的状态。后面我会解释这些变量的重要性。现在，先放在一边吧。 

```c
BOOL light;     // 光源的开/关
BOOL lp;     // L键按下了么?
BOOL fp;     // F键按下了么?
```


现在设置5个变量来控制绕x轴和y轴旋转角度的步长，以及绕x轴和y轴的旋转速度。另外还创建了一个z变量来控制进入屏幕深处的距离。 

```c
GLfloat xrot;     // X 旋转
GLfloat yrot;     // Y 旋转
GLfloat xspeed;     // X 旋转速度
GLfloat yspeed;     // Y 旋转速度

GLfloat z=-5.0f;    // 深入屏幕的距离
```

接着设置用来创建光源的数组。我们将使用两种不同的光。第一种称为环境光。环境光来自于四面八方。所有场景中的对象都处于环境光的照射中。第二种类型的光源叫做漫射光。漫射光由特定的光源产生，并在您的场景中的对象表面上产生反射。处于漫射光直接照射下的任何对象表面都变得很亮，而几乎未被照射到的区域就显得要暗一些。这样在我们所创建的木板箱的棱边上就会产生的很不错的阴影效果。
创建光源的过程和颜色的创建完全一致。前三个参数分别是RGB三色分量，最后一个是alpha通道参数。
因此，下面的代码我们得到的是半亮(0.5f)的白色环境光。如果没有环境光，未被漫射光照到的地方会变得十分黑暗。 

```c
GLfloat LightAmbient[]= { 0.5f, 0.5f, 0.5f, 1.0f };   // 环境光参数
```


下一行代码我们生成最亮的漫射光。所有的参数值都取成最大值1.0f。它将照在我们木板箱的前面，看起来挺好。 

```c
GLfloat LightDiffuse[]= { 1.0f, 1.0f, 1.0f, 1.0f };   // 漫射光参数
```

最后我们保存光源的位置。前三个参数和glTranslate中的一样。依次分别是XYZ轴上的位移。由于我们想要光线直接照射在木箱的正面，所以XY轴上的位移都是0.0f。第三个值是Z轴上的位移。为了保证光线总在木箱的前面，所以我们将光源的位置朝着观察者(就是您哪。)挪出屏幕。我们通常将屏幕也就是显示器的屏幕玻璃所处的位置称作Z轴的0.0f点。所以Z轴上的位移最后定为2.0f。假如您能够看见光源的话，它就浮在您显示器的前方。当然，如果木箱不在显示器的屏幕玻璃后面的话，您也无法看见箱子。『译者注：我很欣赏NeHe的耐心。说真的有时我都打烦了，这么简单的事他这么废话干嘛？但如果什么都清楚，您还会翻着这样的页面看个没完么？』
最后一个参数取为1.0f。这将告诉OpenGL这里指定的坐标就是光源的位置，以后的教程中我会多加解释。 

```c
GLfloat LightPosition[]= { 0.0f, 0.0f, 2.0f, 1.0f };   // 光源位置
```

filter 变量跟踪显示时所采用的纹理类型。第一种纹理(texture 0) 使用gl_nearest(不光滑)滤波方式构建。第二种纹理 (texture 1) 使用gl_linear(线性滤波) 方式，离屏幕越近的图像看起来就越光滑。第三种纹理 (texture 2) 使用 mipmapped滤波方式,这将创建一个外观十分优秀的纹理。根据我们的使用类型，filter 变量的值分别等于 0, 1 或 2 。下面我们从第一种纹理开始。
GLuint texture[3] 为三种不同纹理分配储存空间。它们分别位于在 texture[0], texture[1] 和 texture[2]中。 

```c
GLuint filter;     // 滤波类型
GLuint texture[3];    // 3种纹理的储存空间
```

现在载入一个位图，并用它创建三种不同的纹理。这一课使用glaux辅助库来载入位图，因此在编译时您应该确认是否包含了glaux库。我知道Delphi和VC++都包含了glaux库，但别的语言不能保证都有。『译者注：glaux是OpenGL辅助库，根据OpenGL的跨平台特性，所有平台上的代码都应通用。但辅助库不是正式的OpenGL标准库，没有出现在所有的平台上。但正好在Win32平台上可用。呵呵，BCB当然也没问题了。』这里我只对新增的代码做注解。如果您对某行代码有疑问的话，请查看教程六。那一课很详细的解释了载入、创建纹理的内容。
在上一段代码后面及ReSizeGLScene()之前的位置，我们增加了下面的代码。这和第六课中载入位图的代码几乎相同。 
这段代码调用前面的代码载入位图，并将其转换成3个纹理。Status 变量跟踪纹理是否已载入并被创建了。 

```c
int LoadGLTextures()    // 载入位图并转换成纹理
{
    int Status=FALSE;    // 状态指示器

    AUX_RGBImageRec *TextureImage[1];   // 创建纹理的存储空间

    memset(TextureImage,0,sizeof(void *)*1);  // 将指针设为 NULL
```

现在载入位图并转换成纹理。TextureImage[0]=LoadBMP("Data/Crate.bmp")调用我们的LoadBMP()函数。Data目录下的Crate.bmp将被载入。如果一切正常，图像数据将存放在TextureImage[0]。Status变量被设为TRUE，我们将开始创建纹理。 

```c
    // 载入位图，检查有错，或位图不存在的话退出
    if (TextureImage[0]=LoadBMP("Data/Crate.bmp"))
    {
        Status=TRUE;    // 状态设为 TRUE
```

现在我们已经将图像数据载入TextureImage[0]。我们将用它来创建3个纹理。下面的行告诉OpenGL我们要创建三个纹理，它们将存放在texture[0], texture[1] 和 texture[2] 中。 

```c
        glGenTextures(3, &texture[0]);   // 创建纹理
```

第六课中我们使用了线性滤波的纹理贴图。这需要机器有相当高的处理能力，但它们看起来很不错。这一课中，我们接着要创建的第一种纹理使用 GL_NEAREST方式。从原理上讲，这种方式没有真正进行滤波。它只占用很小的处理能力，看起来也很差。唯一的好处是这样我们的工程在很快和很慢的机器上都可以正常运行。
您会注意到我们在 MIN 和 MAG 时都采用了GL_NEAREST,你可以混合使用 GL_NEAREST 和 GL_LINEAR。纹理看起来效果会好些，但我们更关心速度，所以全采用低质量贴图。MIN_FILTER在图像绘制时小于贴图的原始尺寸时采用。MAG_FILTER在图像绘制时大于贴图的原始尺寸时采用。 

```c
        // 创建 Nearest 滤波贴图
        glBindTexture(GL_TEXTURE_2D, texture[0]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data);
```

The next texture we build is the same type of texture we used in tutorial six. Linear filtered. The only thing that has changed is that we are storing this texture in texture[1] instead of texture[0] because it's our second texture. If we stored it in texture[0] like above, it would overwrite the GL_NEAREST texture (the first texture).  

```c
        // 创建线性滤波纹理
        glBindTexture(GL_TEXTURE_2D, texture[1]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data);
```

下面是创建纹理的新方法。 Mipmapping!『译者注：这个词的中文我翻不出来，不过没关系。看完这一段，您就知道意思最重要。』您可能会注意到当图像在屏幕上变得很小的时候，很多细节将会丢失。刚才还很不错的图案变得很难看。当您告诉OpenGL创建一个 mipmapped的纹理后，OpenGL将尝试创建不同尺寸的高质量纹理。当您向屏幕绘制一个 mipmapped纹理的时候，OpenGL将选择它已经创建的外观最佳的纹理(带有更多细节)来绘制，而不仅仅是缩放原先的图像(这将导致细节丢失)。
我曾经说过有办法可以绕过OpenGL对纹理宽度和高度所加的限制——64、128、256，等等。办法就是 gluBuild2DMipmaps。据我的发现，您可以使用任意的位图来创建纹理。OpenGL将自动将它缩放到正常的大小。
因为是第三个纹理，我们将它存到texture[2]。这样本课中的三个纹理全都创建好了。 

```c
        // 创建 MipMapped 纹理
        glBindTexture(GL_TEXTURE_2D, texture[2]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
		glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST);
```

下面一行生成 mipmapped 纹理。我们使用三种颜色(红，绿，蓝)来生成一个2D纹理。TextureImage[0]->sizeX 是位图宽度，extureImage[0]->sizeY 是位图高度，GL_RGB意味着我们依次使用RGB色彩。GL_UNSIGNED_BYTE 意味着纹理数据的单位是字节。TextureImage[0]->data指向我们创建纹理所用的位图。  

```c
    	gluBuild2DMipmaps(GL_TEXTURE_2D, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data);
    }
```

现在释放用来存放位图数据的内存。我们先查看位图数据是否存放在 TextureImage[0] 中，如果有，删掉。然后释放位图结构以确保内存被释放。 

```c
    if (TextureImage[0])    // 纹理是否存在
    {
        if (TextureImage[0]->data)   // 纹理图像是否存在
        {
            free(TextureImage[0]->data);  // 释放纹理图像占用的内存
        }

        free(TextureImage[0]);   // 释放图像结构
    }
```

最后我们返回 status 变量。如果一切OK，status 变量的值为TRUE。否则为FALSE。 

```c
	return Status;    // 返回 Status 变量
}
```

接着应该载入纹理并初始化OpenGL设置了。InitGL函数的第一行使用上面的代码载入纹理。创建纹理之后，我们调用
glEnable(GL_TEXTURE_2D)启用2D纹理映射。阴影模式设为平滑阴影( smooth shading ）。背景色设为黑色，我们启用深度测试，然后我们启用优化透视计算。 
现在开始设置光源。下面下面一行设置环境光的发光量，光源light1开始发光。这一课的开始处我们我们将环境光的发光量存放在LightAmbient数组中。现在我们就使用此数组(半亮度环境光)。在int InitGL(GLvoid)函数中添加下面的代码。 

```c
glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbient);  // 设置环境光
```

接下来我们设置漫射光的发光量。它存放在LightDiffuse数组中(全亮度白光)。 

```c
glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuse);  // 设置漫射光
```

然后设置光源的位置。位置存放在 LightPosition 数组中(正好位于木箱前面的中心，X－0.0f，Y－0.0f，Z方向移向观察者2个单位<位于屏幕外面>)。 

```c
glLightfv(GL_LIGHT1, GL_POSITION,LightPosition);  // 设置光源位置
```

最后，我们启用一号光源。我们还没有启用GL_LIGHTING，所以您看不见任何光线。记住：只对光源进行设置、定位、甚至启用，光源都不会工作。除非我们启用GL_LIGHTING。 

```c
glEnable(GL_LIGHT1);    // 启用一号光源
```

下一段代码绘制贴图立方体。我只对新增的代码进行注解。如果您对没有注解的代码有疑问，回头看看第六课。 

```c
int DrawGLScene(GLvoid)    // 从这里开始进行所有的绘制
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // 清除屏幕和深度缓存
    glLoadIdentity();    // 重置当前的模型观察矩阵
```

下三行代码放置并旋转贴图立方体。glTranslatef(0.0f,0.0f,z)将立方体沿着Z轴移动Z单位。glRotatef(xrot,1.0f,0.0f,0.0f)将立方体绕X轴旋转xrot。glRotatef(yrot,0.0f,1.0f,0.0f)将立方体绕Y轴旋转yrot。 

```c
    glTranslatef(0.0f,0.0f,z);   // 移入/移出屏幕 z 个单位

    glRotatef(xrot,1.0f,0.0f,0.0f);   // 绕X轴旋转
    glRotatef(yrot,0.0f,1.0f,0.0f);   // 绕Y轴旋转
```

下一行与我们在第六课中的类似。有所不同的是，这次我们绑定的纹理是texture[filter]，而不是上一课中的texture[0]。任何时候，我们按下F键，filter 的值就会增加。如果这个数值大于2，变量filter 将被重置为0。程序初始时，变量filter 的值也将设为0。使用变量filter 我们就可以选择三种纹理中的任意一种。 

```c
    glBindTexture(GL_TEXTURE_2D, texture[filter]);  // 选择由filter决定的纹理

    glBegin(GL_QUADS);    // 开始绘制四边形
```

glNormal3f是这一课的新东西。Normal就是法线的意思，所谓法线是指经过面(多边形）上的一点且垂直于这个面(多边形)的直线。使用光源的时候必须指定一条法线。法线告诉OpenGL这个多边形的朝向，并指明多边形的正面和背面。如果没有指定法线，什么怪事情都可能发生：不该照亮的面被照亮了，多边形的背面也被照亮....。对了，法线应该指向多边形的外侧。

看着木箱的前面您会注意到法线与Z轴正向同向。这意味着法线正指向观察者－您自己。这正是我们所希望的。对于木箱的背面，也正如我们所要的，法线背对着观察者。如果立方体沿着X或Y轴转个180度的话，前侧面的法线仍然朝着观察者，背面的法线也还是背对着观察者。换句话说，不管是哪个面，只要它朝着观察者这个面的法线就指向观察者。由于光源紧邻观察者，任何时候法线对着观察者时，这个面就会被照亮。并且法线越朝着光源，就显得越亮一些。如果您把观察点放到立方体内部，你就会法线里面一片漆黑。因为法线是向外指的。如果立方体内部没有光源的话，当然是一片漆黑。

```c
    // 前侧面
    glNormal3f( 0.0f, 0.0f, 1.0f);   // 法线指向观察者
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    // 后侧面
    glNormal3f( 0.0f, 0.0f,-1.0f);   // 法线背向观察者
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    // 顶面
    glNormal3f( 0.0f, 1.0f, 0.0f);   // 法线向上
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    // 底面
    glNormal3f( 0.0f,-1.0f, 0.0f);   // 法线朝下
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    // 右侧面
    glNormal3f( 1.0f, 0.0f, 0.0f);   // 法线朝右
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    // 左侧面
    glNormal3f(-1.0f, 0.0f, 0.0f);   // 法线朝左
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glEnd();    // 四边形绘制结束
```

下两行代码将xot和yrot的旋转值分别增加xspeed和yspeed个单位。xspeed和yspeed的值越大，立方体转得就越快。 

```c
    xrot+=xspeed;    // xrot 增加 xspeed 单位
    yrot+=yspeed;    // yrot 增加 yspeed 单位
    return TRUE; 
}
```

现在转入WinMain()主函数。我们将在这里增加开关光源、旋转木箱、切换过滤方式以及将木箱移近移远的控制代码。在接近WinMain()函数结束的地方你会看到SwapBuffers(hDC)这行代码。然后就在这一行后面添加如下的代码。
代码将检查L键是否按下过。如果L键已按下，但lp的值不是false的话，意味着L键还没有松开，这时什么都不会发生。

```c
SwapBuffers(hDC);  // 交换缓存
if (keys['L'] && !lp)  // L 键已按下并且松开了?
{
```

如果lp的值是false的话，意味着L键还没按下，或者已经松开了，接着lp将被设为TRUE。同时检查这两个条件的原因是为了防止L键被按住后，这段代码被反复执行，并导致窗体不停闪烁。
lp设为true之后，计算机就知道L键按过了，我们则据此可以切换光源的开/关：布尔变量light控制光源的开关。

```c
    lp=TRUE;  // lp 设为 TRUE
    light=!light;  // 切换光源的 TRUE/FALSE
```

Now we check to see what light ended up being. The first line translated to english means: If light equals false. So if you put it all together, the lines do the following: If light equals false, disable lighting. This turns all lighting off. The command 'else' translates to: if it wasn't false. So if light wasn't false, it must have been true, so we turn lighting on.  

```c
    if (!light)  // 如果没有光源
    {
        glDisable(GL_LIGHTING); // 禁用光源
    }
    else   // 否则
    {
        glEnable(GL_LIGHTING); // 启用光源
    }
}
```

下面的代码查看是否松开了"L"键。如果松开，变量lp将设为false。这意味着"L"键没有按下。如果不作此检查，光源第一次打开之后，就无法再关掉了。计算机会以为"L"键一直按着呢。 

```c
if (!keys['L'])   // L键松开了么?
{
    lp=FALSE;  // 若是，则将lp设为FALSE
}
```

然后对"F"键作相似的检查。如果有按下"F"键并且"F"键没有处于按着的状态或者它就从没有按下过，将变量fp设为true。这意味着这个键正被按着呢。接着将filter变量加一。如果filter变量大于2(因为这里我们的使用的数组是texture[3],大于2的纹理不存在)，我们重置filter变量为0。 

```c
if (keys['F'] && !fp)  // F键按下了么?
{
    fp=TRUE;  // fp 设为 TRUE
    filter+=1;  // filter的值加一
    if (filter>2)  // 大于2了么?
    {
        filter=0;  // 若是重置为0
    }
}
if (!keys['F'])   // F键放开了么?
{
    fp=FALSE;  // 若是fp设为FALSE
}
```

这四行检查是否按下了PageUp键。若是的话，减少z变量的值。这样DrawGLScene函数中包含的glTranslatef(0.0f,0.0f,z)调用将使木箱离观察者更远一点。 

```c
if (keys[VK_PRIOR])  // PageUp按下了?
{
    z-=0.02f;  // 若按下，将木箱移向屏幕内部
}
```

接着四行检查PageDown键是否按下，若是的话，增加z变量的值。这样DrawGLScene函数中包含的glTranslatef(0.0f,0.0f,z)调用将使木箱向着观察者移近一点。 

```c
if (keys[VK_NEXT])  // PageDown按下了么
{
    z+=0.02f;  // 若按下的话，将木箱移向观察者
}
```

现在检查方向键。按下左右方向键xspeed相应减少或增加。按下上下方向键yspeed相应减少或增加。记住在以后的教程中如果xspeed、yspeed的值增加的话，立方体就转的更快。如果一直按着某个方向键，立方体会在那个方向上转的越快。 

```c
if (keys[VK_UP])  // Up方向键按下了么?
{
    xspeed-=0.01f;  // 若是,减少xspeed
}
if (keys[VK_DOWN])  // Down方向键按下了么?
{
    xspeed+=0.01f;  // 若是,增加xspeed
}
if (keys[VK_RIGHT])  // Right方向键按下了么?
{
    yspeed+=0.01f;  // 若是,增加yspeed
}
if (keys[VK_LEFT])  // Left方向键按下了么?
{
    yspeed-=0.01f;  // 若是, 减少yspeed
}
```

像前几课一样，我们最后还需要更正窗体的标题。 

```c
                if (keys[VK_F1])  // F1按下了么?
                {
                    keys[VK_F1]=FALSE;  // 若是将其设为FALSE
                    KillGLWindow();  // 销毁当前窗口
                    fullscreen=!fullscreen;  // 切换全屏/窗口模式
                    // 重建GL窗口
                    if (!CreateGLWindow("NeHe's Textures, Lighting & Keyboard Tutorial",640,480,16,fullscreen))
                    {
                        return 0;  // 若无法创建窗口，程序退出
                    }
                }
            }
        }
    }

    // 关闭
    KillGLWindow();    // 销毁窗口
    return (msg.wParam);    // 退出程序
}
```


这一课完了之后，您应该学会创建和使用这三种不同的纹理映射过滤方式。并使用键盘和场景中的对象交互。最后，您应该学会在场景中应用简单的光源，使得场景看起来更逼真。

# 第八课 混合

在这一课里，我们在纹理的基础上加上了混合，它看起具有透明的效果，当然解释它不是那么容易，当希望你喜欢它。

简单的透明
OpenGL中的绝大多数特效都与某些类型的(色彩)混合有关。混色的定义为，将某个象素的颜色和已绘制在屏幕上与其对应的象素颜色相互结合。至于如何结合这两个颜色则依赖于颜色的alpha通道的分量值，以及/或者所使用的混色函数。Alpha通常是位于颜色值末尾的第4个颜色组成分量。前面这些课我们都是用GL_RGB来指定颜色的三个分量。相应的GL_RGBA可以指定alpha分量的值。更进一步，我们可以使用glColor4f()来代替glColor3f()。
绝大多数人都认为Alpha分量代表材料的透明度。这就是说，alpha值为0.0时所代表的材料是完全透明的。alpha值为1.0时所代表的材料则是完全不透明的。
混色的公式
若您对数学不感冒，而只想看看如何实现透明，请跳过这一节。若您想深入理解(色彩)混合的工作原理，这一节应该适合您吧。『译者注:其实并不难^-^。原文中的公式如下，CKER再唠叨一下吧。其实混合的基本原理是就将要分色的图像各象素的颜色以及背景颜色均按照RGB规则各自分离之后，根据－图像的RGB颜色分量*alpha值+背景的RGB颜色分量*(1-alpha值)－这样一个简单公式来混合之后，最后将混合得到的RGB分量重新合并。』
公式如下：
$$
(Rs Sr + Rd Dr, Gs Sg + Gd Dg, Bs Sb + Bd Db, As Sa + Ad Da)
$$
OpenGL按照上面的公式计算这两个象素的混色结果。小写的s和r分别代表源象素和目标象素。大写的S和D则是相应的混色因子。这些决定了您如何对这些象素混色。绝大多数情况下，各颜色通道的alpha混色值大小相同，这样对源象素就有 (As, As, As, As)，目标象素则有(1, 1, 1, 1) - (As, As, As, As)。上面的公式就成了下面的模样:
$$
(Rs As + Rd (1 - As), Gs As + Gd (1 - As), Bs As + Bs (1 - As), As As + Ad (1 - As))
$$
这个公式会生成透明/半透明的效果。

OpenGL中的混色
在OpenGL中实现混色的步骤类似于我们以前提到的OpenGL过程。接着设置公式，并在绘制透明对象时关闭写深度缓存。因为我们想在半透明的图形背后绘制 对象。这不是正确的混色方法，但绝大多数时候这种做法在简单的项目中都工作的很好。
Rui Martins 的补充： 正确的混色过程应该是先绘制全部的场景之后再绘制透明的图形。并且要按照与深度缓存相反的次序来绘制(先画最远的物体)。
考虑对两个多边形(1和2)进行alpha混合，不同的绘制次序会得到不同的结果。(这里假定多边形1离观察者最近，那么正确的过程应该先画多边形2，再画多边形1。正如您再现实中所见到的那样，从这两个<透明的>多边形背后照射来的光线总是先穿过多边形2，再穿过多边形1，最后才到达观察者的眼睛。)
在深度缓存启用时，您应该将透明图形按照深度进行排序，并在全部场景绘制完毕之后再绘制这些透明物体。否则您将得到不正确的结果。我知道某些时候这样做是很令人痛苦的，但这是正确的方法。
我们将使用第七课的代码。一开始先在代码开始处增加两个新的变量。出于清晰起见，我重写了整段代码。

```c
bool blend;   // 是否混合?
bool bp;   // B 键按下了么?
```

然后往下移动到 LoadGLTextures() 这里。找到" if (TextureImage[0]=LoadBMP("Data/Crate.bmp")) "这一行。我们现在使用有色玻璃纹理来代替上一课中的木箱纹理。 

```c
if (TextureImage[0]=LoadBMP("Data/glass.bmp")) // 载入玻璃位图
```

在InitGL()代码段加入以下两行。第一行以全亮度绘制此物体，并对其进行50%的alpha混合(半透明)。当混合选项打开时，此物体将会产生50%的透明效果。第二行设置所采用的混合类型。
Rui Martins 的补充: alpha通道的值为 0.0意味着物体材质是完全透明的。1.0 则意味着完全不透明。  

```c
glColor4f(1.0f,1.0f,1.0f,0.5f);  // 全亮度， 50% Alpha 混合
glBlendFunc(GL_SRC_ALPHA,GL_ONE); // 基于源象素alpha通道值的半透明混合函数
```

在接近第七课结尾处的地方找到下面的代码段。 

```c
if (keys[VK_LEFT])  // Left方向键按下了么?
{
    yspeed-=0.01f;  // 若是, 减少yspeed
}
```

接着上面的代码，我们增加如下的代码。这几行监视B键是否按下。如果是的话，计算机检查混合选项是否已经打开。然后将其置为相反的状态。 

```c
if (keys['B'] && !bp)  // B 健按下且bp为 FALSE么?
{
    bp=TRUE;  // 若是， bp 设为 TRUE
    blend = !blend;  // 切换混合选项的 TRUE / FALSE
    if(blend)  // 混合打开了么?
    {
        glEnable(GL_BLEND); // 打开混合
        glDisable(GL_DEPTH_TEST); // 关闭深度测试
    }
    else   // 否则
    {
        glDisable(GL_BLEND); // 关闭混合
        glEnable(GL_DEPTH_TEST); // 打开深度测试
    }
}
if (!keys['B'])   // B 键松开了么?
{
    bp=FALSE;  // 若是， bp设为 FALSE
}
```

但是怎样才能在使用纹理贴图的时候指定混合时的颜色呢?很简单，在调整贴图模式时，文理贴图的每个象素点的颜色都是由alpha通道参数与当前地象素颜色相乘所得到的。比如，绘制的颜色是 (0.5, 0.6, 0.4),我们会把颜色相乘得到(0.5, 0.6, 0.4, 0.2) (alpha参数在没有指定时，缺省为零)。
就是如此！OpenGL实现Alpha混合的确很简单！

原文注 (11/13/99)
我(NeHe)混色代码进行了修改，以使显示的物体看起来更逼真。同时对源象素和目的象素使用alpha参数来混合，会导致物体的人造痕迹看起来很明显。 会使得物体的背面沿着侧面的地方显得更暗。基本上物体会看起来很怪异。我所用的混色方法也许不是最好的，但的确能够工作。启用光源之后，物体看起来很逼真。感谢Tom提供的原始代码，他采用的混色方法是正确的，但物体看起来并不象所期望的那样吸引人:)
代码所作的再次修改是因为在某些显卡上glDepthMask()函数存在寻址问题。这条命令在某些卡上启用或关闭深度缓冲测试时似乎不是很有效，所以我已经将启用或关闭深度缓冲测试的代码转成老式的glEnable和glDisable。

纹理贴图的Alpha混合
用于纹理贴图的alpha参数可以象颜色一样从问题贴图中读取。方法如下，您需要在载入所需的材质同时取得其的alpha参数。然后在调用glTexImage2D()时使用GL_RGBA的颜色格式。

# 第九课 3D空间中移动图像

你想知道如何在3D空间中移动物体，你想知道如何在屏幕上绘制一个图像，而让图像的背景色变为透明，你希望有一个简单的动画。这一课将教会你所有的一切。前面的课程涵盖了基础的OpenGL，每一课都是在前一课的基础上创建的。这一课是前面几课知识的综合，当你学习这课时，请确保你已经掌握了前面几课的知识。

欢迎进入第九课。到现在为止，您应该很好的理解OpenGL了。『CKER：如果没有的话，一定是我翻译的罪过......』。您已经学会了设置一个OpenGL窗口的每个细节。学会在旋转的物体上贴图并打上光线以及混色(透明)处理。这一课应该算是第一课中级教程。您将学到如下的知识：在3D场景中移动位图，并去除位图上的黑色象素(使用混色)。接着为黑白纹理上色，最后您将学会创建丰富的色彩，并把上过不同色彩的纹理相互混合，得到简单的动画效果。
我们在第一课的代码基础上进行修改。先在程序源码的开始处增加几个变量。出于清晰起见，我重写了整段代码。 

```c
#include <stdio.h>   // 标准输入输出库头文件
#include <glaux.h>   // GLaux库的头文件
```

下列这几行新加的。twinkle 和 tp 是布尔变量, 表示它们只能设为 TRUE 或 FALSE。 twinkle用来跟踪 闪烁 效果是否启用。 tp用来检查 'T'键有没有被按下或松开. (按下时 tp=TRUE, 松开时 tp=FALSE). 

```c
BOOL twinkle;   // 闪烁的星星
BOOL tp;    // 'T' 按下了么?
```

num 跟踪屏幕上所绘制的星星数。这个数字被定义为一个常量。这意味着无法在以后的代码中对其进行修改。这么做的原因是因为您无法重新定义一个数组。因此，如果我们定义一个50颗星星的数组，然后又将num增加到51的话，就会出错『CKER：数组越界』。不过您还是可以(也只可以)在这一行上随意修改这个数字。但是以后请您别再改动 num 的值了，除非您想看见灾难发生。 

num 跟踪屏幕上所绘制的星星数。这个数字被定义为一个常量。这意味着无法在以后的代码中对其进行修改。这么做的原因是因为您无法重新定义一个数组。因此，如果我们定义一个50颗星星的数组，然后又将num增加到51的话，就会出错『CKER：数组越界』。不过您还是可以(也只可以)在这一行上随意修改这个数字。但是以后请您别再改动 num 的值了，除非您想看见灾难发生。 

```c
const num=50;    // 绘制的星星数
```

现在我们来创建一个结构。 结构这词听起来有点可怕，但实际上并非如此。 一个结构使用一组简单类型的数据 (以及变量等)来表达较大的具有相似性的数据组合。 我们知道我们在保持对星星的跟踪。 您可以看到下面的第七行就是 stars；并且每个星星有三个整型的色彩值。第三行 int r,g,b设置了三个整数. 一个红色 (r), 一个绿色 (g), 以及一个蓝色 (b). 此外，每个星星离屏幕中心的距离不同, 而且可以是以屏幕中心为原点的任意360度中的一个角度。如果你看下面第四行的话, 会发现我们使用了一个叫做 dist的浮点数来保持对距离 的跟踪. 第五行则用一个叫做 angle的浮点数保持对星星角度值的跟踪。
因此我们使用了一组数据来描述屏幕上星星的色彩, 距离, 和角度。 不幸的是我们不止对一个星星进行跟踪。但是无需创建 50 个红色值、 50 个绿色值、 50 个蓝色值、 50 个距离值 以及 50 个角度值，而只需创建一个数组star。 star数组的每个元素都是stars类型的，里面存放 了描述星星的所有数据。star数组在下面的第八行创建。 第八行的样子是这样的： stars star[num]。数组类型是 stars结构. 所数组 能存放所有stars结构的信息。 数组名字是 star. 数组大小是 [num]。 数组中存放着 stars结构的元素. 跟踪结构元素会比跟踪各自分开的变量容易的多. 不过这样也很笨, 因为我们竟然不能改变常量 num来增减星星 数量。

```c
typedef struct    // 为星星创建一个结构
{
    int r, g, b;   // 星星的颜色
    GLfloat dist;   // 星星距离中心的距离
    GLfloat angle;   // 当前星星所处的角度
}
stars;    // 结构命名为stars
stars star[num];   // 使用 'stars' 结构生成一个包含 'num'个元素的 'star'数组
```

接下来我们设置几个跟踪变量：星星离观察者的距离变量(zoom)，我们所见到的星星所处的角度(tilt)，以及使闪烁的星星绕Z轴自转的变量spin。
loop变量用来绘制50颗星星。texture[1]用来存放一个黑白纹理。如果您需要更多的纹理的话，您应该增加texture数组的大小至您决定采用的纹理个数。 

```c
GLfloat zoom=-15.0f;   // 星星离观察者的距离
GLfloat tilt=90.0f;   // 星星的倾角
GLfloat spin;    // 闪烁星星的自转

GLuint loop;    // 全局 Loop 变量
GLuint texture[1];   // 存放一个纹理
```

紧接着上面的代码就是我们用来载入纹理的代码。我不打算再详细的解释这段代码。这跟我们在第六、七、八课中所用的代码是一模一样的。这一次载入的位图叫做star.bmp。这里我们使用glGenTextures(1, &texture[0])，来生成一个纹理。纹理采用线性滤波方式。 

```c
AUX_RGBImageRec *LoadBMP(char *Filename)  // 载入位图文件
{
    FILE *File=NULL;   // 文件句柄

    if (!Filename)   // 确认已给出文件名
    {
        return NULL;   // 若无返回 NULL
    }

    File=fopen(Filename,"r");  // 检查文件是否存在

    if (File)   // 文件存在么?
    {
        fclose(File);   // 关闭文件句柄
        return auxDIBImageLoad(Filename); // 载入位图并返回指针
    }
    return NULL;   // 如果载入失败返回 NULL
}
```

下面的代码(调用上面的代码)载入位图，并转换成纹理。变量用来跟踪纹理是否已载入并创建好了。 

```c
int LoadGLTextures()   // 载入位图并转换成纹理
{
    int Status=FALSE;   // 状态指示器

    AUX_RGBImageRec *TextureImage[1];  // 为纹理分配存储空间

    memset(TextureImage,0,sizeof(void *)*1); // 将指针设为 NULL

    // 载入位图，查错，如果未找到位图文件则退出
    if (TextureImage[0]=LoadBMP("Data/Star.bmp"))
    {
        Status=TRUE;   // 将 Status 设为TRUE

        glGenTextures(1, &texture[0]);  // 创建一个纹理

        // 创建一个线性滤波纹理
        glBindTexture(GL_TEXTURE_2D, texture[0]);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
        glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data);
    }

    if (TextureImage[0])   // 如果纹理存在
    {
        if (TextureImage[0]->data)  // 如果纹理图像存在
        {
            free(TextureImage[0]->data); // 释放纹理图像所占的内存
        }

        free(TextureImage[0]);  // 释放图像结构
    }

    return Status;   // 返回 Status的值
}
```


现在设置OpenGL的渲染方式。这里不打算使用深度测试，如果您使用第一课的代码的话，请确认是否已经去掉了 glDepthFunc(GL_LEQUAL); 和 glEnable(GL_DEPTH_TEST);两行。否则，您所见到的效果将会一团糟。这里我们使用了纹理映射，因此请您确认您已经加上了这些第一课中所没有的代码。您会注意到我们通过混色来启用了纹理映射。 

```c
int InitGL(GLvoid)   // 此处开始对OpenGL进行所有设置
{
    if (!LoadGLTextures())   // 调用纹理载入子例程
    {
        return FALSE;   // 如果未能载入，返回FALSE
    }

    glEnable(GL_TEXTURE_2D);  // 启用纹理映射
    glShadeModel(GL_SMOOTH);  // 启用阴影平滑
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);  // 黑色背景
    glClearDepth(1.0f);   // 设置深度缓存
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // 真正精细的透视修正
    glBlendFunc(GL_SRC_ALPHA,GL_ONE);  // 设置混色函数取得半透明效果
    glEnable(GL_BLEND);   // 启用混色
```

以下是新增的代码。设置了每颗星星的起始角度、距离、和颜色。您会注意到修改结构的属性有多容易。全部50颗星星都会被循环设置。要改变star[1]的角度我们所要做的只是star[1].angle={某个数值}；就这么简单！ 

```c
    for (loop=0; loop<num; loop++)  // 创建循环设置全部星星
    {
        star[loop].angle=0.0f;  // 所有星星都从零角度开始
```

第loop颗星星离中心的距离是将loop的值除以星星的总颗数，然后乘上5.0f。基本上这样使得后一颗星星比前一颗星星离中心更远一点。这样当loop为50时(最后一颗星星)，loop 除以 num正好是1.0f。之所以要乘以5.0f是因为1.0f*5.0f 就是 5.0f。『CKER：废话，废话！这老外怎么跟孔乙己似的！:)』5.0f已经很接近屏幕边缘。我不想星星飞出屏幕，5.0f是最好的选择了。当然如果如果您将场景设置的更深入屏幕里面的话，也许可以使用大于5.0f的数值，但星星看起来就更小一些(都是透视的缘故)。
您还会注意到每颗星星的颜色都是从0～255之间的一个随机数。也许您会奇怪为何这里的颜色得取值范围不是OpenGL通常的0.0f～1.0f之间。这里我们使用的颜色设置函数是glColor4ub，而不是以前的glColor4f。ub意味着参数是Unsigned Byte型的。一个byte的取值范围是0～255。这里使用byte值取随机整数似乎要比取一个浮点的随机数更容易一些。 

```c
        star[loop].dist=(float(loop)/num)*5.0f; // 计算星星离中心的距离
        star[loop].r=rand()%256;  // 为star[loop]设置随机红色分量
        star[loop].g=rand()%256;  // 为star[loop]设置随机红色分量
        star[loop].b=rand()%256;  // 为star[loop]设置随机红色分量
    }
    return TRUE;   // 初始化一切OK
}
```

Resize的代码也是一样的，现在我们转入绘图代码。如果您使用第一课的代码，删除旧的DrawGLScene代码，只需将下面的代码复制过去就行了。实际上，第一课的代码只有两行，所以没太多东西要删掉的。 

```c
int DrawGLScene(GLvoid)   // 此过程中包括所有的绘制代码
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除屏幕及深度缓存
    glBindTexture(GL_TEXTURE_2D, texture[0]); // 选择纹理

    for (loop=0; loop<num; loop++)  // 循环设置所有的星星
    {
        glLoadIdentity();  // 绘制每颗星星之前，重置模型观察矩阵
        glTranslatef(0.0f,0.0f,zoom);  // 深入屏幕里面
        glRotatef(tilt,1.0f,0.0f,0.0f);  // 倾斜视角
```

现在我们来移动星星。星星开始时位于屏幕的中心。我们要做的第一件事是把场景沿Y轴旋转。如果我们旋转90度的话，X轴不再是自左至右的了，他将由里向外穿出屏幕。为了让大家更清楚些，举个例子。假想您站在房子中间。再设想您左侧的墙上写着-x，前面的墙上写着-z，右面墙上就是+x咯，您身后的墙上则是+z。加入整个房子向右转90度，但您没有动，那么前面的墙上将是-x而不再是-z了。所有其他的墙也都跟着移动。-z出现在右侧，+z出现在左侧，+x出现在您背后。神经错乱了吧？通过旋转场景，我们改变了x和z平面的方向。
第二行代码沿x轴移动一个正值。通常x轴上的正值代表移向了屏幕的右侧(也就是通常的x轴的正向)，但这里由于我们绕y轴旋转了坐标系，x轴的正向可以是任意方向。如果我们转180度的话，屏幕的左右侧就镜像反向了。因此，当我们沿 x轴正向移动时，可能向左，向右，向前或向后。 

```c
        glRotatef(star[loop].angle,0.0f,1.0f,0.0f); // 旋转至当前所画星星的角度
        glTranslatef(star[loop].dist,0.0f,0.0f); // 沿X轴正向移动
```

接着的代码带点小技巧。星星实际上是一个平面的纹理。现在您在屏幕中心画了个平面的四边形然后贴上纹理，这看起来很不错。一切都如您所想的那样。但是当您当您沿着y轴转上个90度的话，纹理在屏幕上就只剩右侧和左侧的两条边朝着您。看起来就是一条细线。这不是我们所想要的。我们希望星星永远正面朝着我们，而不管屏幕如何旋转或倾斜。
我们通过在绘制星星之前，抵消对星星所作的任何旋转来实现这个愿望。您可以采用逆序来抵消旋转。当我们倾斜屏幕时，我们实际上以当前角度旋转了星星。通过逆序，我们又以当前角度"反旋转"星星。也就是以当前角度的负值来旋转星星。就是说，如果我们将星星旋转了10度的话，又将其旋转-10度来使星星在那个轴上重新面对屏幕。下面的第一行抵消了沿y轴的旋转。然后，我们还需要抵消掉沿x轴的屏幕倾斜。要做到这一点，我们只需要将屏幕再旋转-tilt倾角。在抵消掉x和y轴的旋转后，星星又完全面对着我们了。

```c
        glRotatef(-star[loop].angle,0.0f,1.0f,0.0f); // 取消当前星星的角度
        glRotatef(-tilt,1.0f,0.0f,0.0f); // 取消屏幕倾斜
```

如果 twinkle 为 TRUE，我们在屏幕上先画一次不旋转的星星：将星星总数(num) 减去当前的星星数(loop)再减去1，来提取每颗星星的不同颜色(这么做是因为循环范围从0到num-1)。举例来说，结果为10的时候，我们就使用10号星星的颜色。这样相邻星星的颜色总是不同的。这不是个好法子，但很有效。最后一个值是alpha通道分量。这个值越小，这颗星星就越暗。
由于启用了twinkle，每颗星星最后会被绘制两遍。程序运行起来会慢一些，这要看您的机器性能如何了。但两遍绘制的星星颜色相互融合，会产生很棒的效果。同时由于第一遍的星星没有旋转，启用twinkle后的星星看起来有一种动画效果。(如果您这里看不懂得话，就自己去看程序的运行效果吧。)
值得注意的是给纹理上色是件很容易的事。尽管纹理本身是黑白的，纹理将变成我们在绘制它之前选定的任意颜色。此外，同样值得注意的是我们在这里使用的颜色值是byte型的，而不是通常的浮点数。甚至alpha通道分量也是如此。 

```c
        if (twinkle)   // 启用闪烁效果
        {
            // 使用byte型数值指定一个颜色
            glColor4ub(star[(num-loop)-1].r,star[(num-loop)-1].g,star[(num-loop)-1].b,255);
            glBegin(GL_QUADS);  // 开始绘制纹理映射过的四边形
            glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f,-1.0f, 0.0f);
            glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f,-1.0f, 0.0f);
            glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 0.0f);
            glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 0.0f);
            glEnd();  // 四边形绘制结束
        }
```

现在绘制第二遍的星星。唯一和前面的代码不同的是这一遍的星星肯定会被绘制，并且这次的星星绕着z轴旋转。 

```c
        glRotatef(spin,0.0f,0.0f,1.0f);  // 绕z轴旋转星星
        // 使用byte型数值指定一个颜色
        glColor4ub(star[loop].r,star[loop].g,star[loop].b,255);
        glBegin(GL_QUADS);  // 开始绘制纹理映射过的四边形
        glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f,-1.0f, 0.0f);
        glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f,-1.0f, 0.0f);
        glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 0.0f);
        glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 0.0f);
        glEnd();   // 四边形绘制结束
```

以下的代码代表星星的运动。我们增加spin的值来旋转所有的星星(公转)。然后，将每颗星星的自转角度增加loop/num。这使离中心更远的星星转的更快。最后减少每颗星星离屏幕中心的距离。这样看起来，星星们好像被不断地吸入屏幕的中心。 

```c
        spin+=0.01f;   // 星星的公转
        star[loop].angle+=float(loop)/num; // 改变星星的自转角度
        star[loop].dist-=0.01f;  // 改变星星离中心的距离
```

接着几行检查星星是否已经碰到了屏幕中心。当星星碰到屏幕中心时，我们为它赋一个新颜色，然后往外移5个单位，这颗星星将踏上它回归屏幕中心的旅程。 

```c
        if (star[loop].dist<0.0f)  // 星星到达中心了么
        {
            star[loop].dist+=5.0f;  // 往外移5个单位
            star[loop].r=rand()%256; // 赋一个新红色分量
            star[loop].g=rand()%256; // 赋一个新绿色分量
            star[loop].b=rand()%256; // 赋一个新蓝色分量
        }	
	}
	return TRUE;   // 一切正常
}
```

现在我们添加监视键盘的代码。下移到WinMain()。找到SwapBuffers(hDC)一行。我们就在这一行后面增加键盘监视代码。
代码将检查T键是否已按下。如果T键按下过，并且又放开了，if块内的代码将被执行。如果twinkle为FALSE，他将变为TRUE。反之亦然。只要T键按下， tp就变为TRUE。这样处理可以防止如果您一直按着T键的话，块内的代码被反复执行。 

```c
SwapBuffers(hDC);  // 切换缓冲
if (keys['T'] && !tp)  // 是否T 键已按下并且 tp值为 FALSE
{
    tp=TRUE;  // 若是，将tp设为TRUE
    twinkle=!twinkle;  // 翻转 twinkle的值
}
```

下面的代码检查是否松开了T键。若是，使 tp=FALSE。除非tp的值为FALSE，否则按着T键时什么也不会发生。所以这行代码很重要。 

```c
if (!keys['T'])   // T 键已松开了么？
{
    tp=FALSE;  // 若是 ，tp为 FALSE
}
```

余下的代码检查上、下方向键，向上翻页键或向下翻页键是否按下。 

```c
if (keys[VK_UP])  // 上方向键按下了么？
{
    tilt-=0.5f;  // 屏幕向上倾斜
}

if (keys[VK_DOWN])  // 下方向键按下了么？
{
    tilt+=0.5f;  // 屏幕向下倾斜
}

if (keys[VK_PRIOR])  // 向上翻页键按下了么
{
    zoom-=0.2f;  // 缩小
}

if (keys[VK_NEXT])  // 向下翻页键按下了么？
{
    zoom+=0.2f;  // 放大
}
```

像以前一样，确认窗口的标题是否正确。 

```c
        if (keys[VK_F1])  // F1键按下了么?
        {
            keys[VK_F1]=FALSE;  // 若是，使对应的Key数组中的值为 FALSE
            KillGLWindow();  // 销毁当前的窗口
            fullscreen=!fullscreen;  // 切换 全屏 / 窗口 模式
            // 重建 OpenGL 窗口
            if (!CreateGLWindow("NeHe's 透明纹理实例",640,480,16,fullscreen))
            {
                return 0;  // 如果窗口未能创建，程序退出
            }
        }
    }
}
```


这一课我尽我所能来解释如何加载一个灰阶位图纹理，(使用混色)去掉它的背景色后，再给它上色，最后让它在3D场景中移动。我已经向您展示了如何创建漂亮的颜色与动画效果。实现原理是在原始位图上再重叠一份位图拷贝。到现在为止，只要您很好的理解了我所教您的一切，您应该已经能够毫无问题的制作您自己的3D Demo了。所有的基础知识都已包括在内！

# 第十课  加载3D世界，并在其中漫游

在这一课中，你将学会如何加载3D世界，并在3D世界中漫游。这一课使用第一课的代码，当然在课程说明中我只介绍改变了代码。

这一课是由Lionel Brits (βtelgeuse)所写的。在本课中我们只对增加的代码做解释。当然只添加课程中所写的代码，程序是不会运行的。如果您有兴趣知道下面的每一行代码是如何运行的话，请下载完整的源码，并在浏览这一课的同时，对源码进行跟踪。
好了现在欢迎来到名不见经传的第十课。到现在为止，您应该有能力创建一个旋转的立方体或一群星星了，对3D编程也应该有些感觉了吧？但还是请等一下！不要立马冲动地要开始写个Quake
IV，好不好...:)。只靠旋转的立方体还很难来创造一个可以决一死战的酷毙了的对手....:)。现在这些日子您所需要的是一个大一点的、更复杂些的、动态3D世界，它带有空间的六自由度和花哨的效果如镜像、入口、扭曲等等，当然还要有更快的帧显示速度。这一课就要解释一个基本的3D世界"结构"，以及如何在这个世界里游走。
数据结构
当您想要使用一系列的数字来完美的表达3D环境时，随着环境复杂度的上升，这个工作的难度也会随之上升。出于这个原因，我们必须将数据归类,使其具有更多的可操作性风格。在程序清单头部出现了sector(区段)的定义。每个3D世界基本上可以看作是sector(区段)的集合。一个sector(区段)可以是一个房间、一个立方体、或者任意一个闭合的区间。 

```c
typedef struct tagSECTOR   // 创建Sector区段结构
{
    int numtriangles;   // Sector中的三角形个数
    TRIANGLE* triangle;   // 指向三角数组的指针
} SECTOR;    // 命名为SECTOR
```

一个sector(区段)包含了一系列的多边形，所以下一个目标就是triangle(我们将只用三角形，这样写代码更容易些)。 

```c
typedef struct tagTRIANGLE   // 创建Triangle三角形结构
{
    VERTEX vertex[3];   // VERTEX矢量数组，大小为3
} TRIANGLE;    // 命名为 TRIANGLE
```

三角形本质上是由一些(两个以上)顶点组成的多边形，顶点同时也是我们的最基本的分类单位。顶点包含了OpenGL真正感兴趣的数据。我们用3D空间中的坐标值(x,y,z)以及它们的纹理坐标(u,v)来定义三角形的每个顶点。 

```c
typedef struct tagVERTEX   // 创建Vertex顶点结构
{
    float x, y, z;    // 3D 坐标
    float u, v;    // 纹理坐标
} VERTEX;    // 命名为VERTEX
```

载入文件
在程序内部直接存储数据会让程序显得太过死板和无趣。从磁盘上载入世界资料，会给我们带来更多的弹性，可以让我们体验不同的世界，而不用被迫重新编译程序。另一个好处就是用户可以切换世界资料并修改它们而无需知道程序如何读入输出这些资料的。数据文件的类型我们准备使用文本格式。这样编辑起来更容易，写的代码也更少。等将来我们也许会使用二进制文件。

问题是，怎样才能从文件中取得数据资料呢？首先，创建一个叫做SetupWorld()的新函数。把这个文件定义为filein，并且使用只读方式打开文件。我们必须在使用完毕之后关闭文件。大家一起来看看现在的代码：

```c
// 先前的定义： char* worldfile = "data\\world.txt";
void SetupWorld()    // 设置我们的世界
{
    FILE *filein;    // 工作文件
    filein = fopen(worldfile, "rt");  // 打开文件

    ...
    (读入数据资料))
    ...

    fclose(filein);    // 关闭文件
    return;    // 返回
}
```

下一个挑战是将每个单独的文本行读入变量。这有很多办法可以做到。一个问题是文件中并不是所有的行都包含有意义的信息。空行和注释不应该被读入。我们创建了一个叫做readstr()的函数。这个函数会从数据文件中读入一个有意义的行至一个已经初始化过的字符串。下面就是代码：

```c
void readstr(FILE *f,char *string)   // 读入一个字符串
{
    do    // 循环开始
    {
        fgets(string, 255, f);   // 读入一行
    } while ((string[0] == '/') || (string[0] == '\n')); // 考察是否有必要进行处理
    return;    // 返回
}
```

下一步我们读入区段数据。这一课将只处理一个区段，不过实现一个多区段引擎也很容易。让我们将注意力转回SetupWorld()。程序必须知道区段内包含了多少个三角形。我们在数据文件中以下面这种形式定义三角形数量：
接下来是读取三角形数量的代码： 

```c
int numtriangles;    // 区段中的三角形数量
char oneline[255];    // 存储数据的字符串
...
readstr(filein,oneline);   // 读入一行数据
sscanf(oneline, "NUMPOLLIES %d\n", &numtriangles);  // 读入三角形数量
```

余下的世界载入过程采用了相似的方法。接着，我们对区段进行初始化，并读入部分数据： 

```c
// 先前的定义: SECTOR sector1;
char oneline[255];    // 存储数据的字符串
int numtriangles;    // 区段的三角形数量
float x, y, z, u, v;    // 3D 和 纹理坐标
...
sector1.triangle = new TRIANGLE[numtriangles];  // 为numtriangles个三角形分配内存并设定指针
sector1.numtriangles = numtriangles;   // 定义区段1中的三角形数量
// 遍历区段中的每个三角形
for (int triloop = 0; triloop < numtriangles; triloop++) // 遍历所有的三角形
{
    // 遍历三角形的每个顶点
    for (int vertloop = 0; vertloop < 3; vertloop++) // 遍历所有的顶点
    {
        readstr(filein,oneline);  // 读入一行数据
        // 读入各自的顶点数据
        sscanf(oneline, "%f %f %f %f %f", &x, &y, &z, &u, &v);
        // 将顶点数据存入各自的顶点
        sector1.triangle[triloop].vertex[vertloop].x = x; // 区段 1, 第 triloop 个三角形, 第 vertloop 个顶点, 值 x =x
        sector1.triangle[triloop].vertex[vertloop].y = y; // 区段 1, 第 triloop 个三角形, 第 vertloop 个顶点, 值 y =y
        sector1.triangle[triloop].vertex[vertloop].z = z; // 区段 1, 第 triloop 个三角形, 第 vertloop 个顶点, 值 z =z
        sector1.triangle[triloop].vertex[vertloop].u = u; // 区段 1, 第 triloop 个三角形, 第 vertloop 个顶点, 值 u =u
        sector1.triangle[triloop].vertex[vertloop].v = v; // 区段 1, 第 triloop 个三角形, 第 vertloop 个顶点, 值 e=v
    }
}
```

数据文件中每个三角形都以如下形式声明:

```
X1 Y1 Z1 U1 V1
X2 Y2 Z2 U2 V2
X3 Y3 Z3 U3 V3
```

显示世界
现在区段已经载入内存，我们下一步要在屏幕上显示它。到目前为止，我们所作过的都是些简单的旋转和平移。但我们的镜头始终位于原点(0，0，0)处。任何一个不错的3D引擎都会允许用户在这个世界中游走和遍历，我们的这个也一样。实现这个功能的一种途径是直接移动镜头并绘制以镜头为中心的3D环境。这样做会很慢并且不易用代码实现。我们的解决方法如下：
根据用户的指令旋转并变换镜头位置。
围绕原点，以与镜头相反的旋转方向来旋转世界。(让人产生镜头旋转的错觉)
以与镜头平移方式相反的方式来平移世界(让人产生镜头移动的错觉)。
这样实现起来就很简单.
下面从第一步开始吧(平移并旋转镜头)。

```c
if (keys[VK_RIGHT])    // 右方向键按下了么?
{
    yrot -= 1.5f;    // 向左旋转场景
}

if (keys[VK_LEFT])    // 左方向键按下了么?
{
    yrot += 1.5f;    // 向右侧旋转场景
}

if (keys[VK_UP])    // 向上方向键按下了么?
{
    xpos -= (float)sin(heading*piover180) * 0.05f;  // 沿游戏者所在的X平面移动
    zpos -= (float)cos(heading*piover180) * 0.05f;  // 沿游戏者所在的Z平面移动
    if (walkbiasangle >= 359.0f)   // 如果walkbiasangle大于359度
    {
        walkbiasangle = 0.0f;   // 将 walkbiasangle 设为0
    }
    else    // 否则
    {
        walkbiasangle+= 10;   // 如果 walkbiasangle < 359 ，则增加 10
    }
    walkbias = (float)sin(walkbiasangle * piover180)/20.0f; // 使游戏者产生跳跃感
}

if (keys[VK_DOWN])    // 向下方向键按下了么？
{
    xpos += (float)sin(heading*piover180) * 0.05f;  // 沿游戏者所在的X平面移动
    zpos += (float)cos(heading*piover180) * 0.05f;  // 沿游戏者所在的Z平面移动
    if (walkbiasangle <= 1.0f)   // 如果walkbiasangle小于1度
    {
        walkbiasangle = 359.0f;   // 使 walkbiasangle 等于 359
    }
    else    // 否则
    {
        walkbiasangle-= 10;   // 如果 walkbiasangle > 1 减去 10
    }
    walkbias = (float)sin(walkbiasangle * piover180)/20.0f; // 使游戏者产生跳跃感
}
```

这个实现很简单。当左右方向键按下后，旋转变量yrot
相应增加或减少。当前后方向键按下后，我们使用sine和cosine函数重新生成镜头位置(您需要些许三角函数学的知识:-)。Piover180
是一个很简单的折算因子用来折算度和弧度。
接着您可能会问：walkbias是什么意思？这是NeHe的发明的单词:-)。基本上就是当人行走时头部产生上下摆动的幅度。我们使用简单的sine正弦波来调节镜头的Y轴位置。如果不添加这个而只是前后移动的话，程序看起来就没这么棒了。
现在，我们已经有了下面这些变量。可以开始进行步骤2和3了。由于我们的程序还不太复杂，我们无需新建一个函数，而是直接在显示循环中完成这些步骤。 

```c
int DrawGLScene(GLvoid)    // 绘制 OpenGL 场景
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除 场景 和 深度缓冲
    glLoadIdentity();   // 重置当前矩阵


    GLfloat x_m, y_m, z_m, u_m, v_m;  // 顶点的临时 X, Y, Z, U 和 V 的数值
    GLfloat xtrans = -xpos;   // 用于游戏者沿X轴平移时的大小
    GLfloat ztrans = -zpos;   // 用于游戏者沿Z轴平移时的大小
    GLfloat ytrans = -walkbias-0.25f;  // 用于头部的上下摆动
    GLfloat sceneroty = 360.0f - yrot;  // 位于游戏者方向的360度角

    int numtriangles;   // 保有三角形数量的整数

    glRotatef(lookupdown,1.0f,0,0);   // 上下旋转
    glRotatef(sceneroty,0,1.0f,0);   // 根据游戏者正面所对方向所作的旋转

    glTranslatef(xtrans, ytrans, ztrans);  // 以游戏者为中心的平移场景
    glBindTexture(GL_TEXTURE_2D, texture[filter]);  // 根据 filter 选择的纹理

    numtriangles = sector1.numtriangles;  // 取得Sector1的三角形数量

    // 逐个处理三角形
    for (int loop_m = 0; loop_m < numtriangles; loop_m++) // 遍历所有的三角形
    {
        glBegin(GL_TRIANGLES);   // 开始绘制三角形
        glNormal3f( 0.0f, 0.0f, 1.0f);  // 指向前面的法线
        x_m = sector1.triangle[loop_m].vertex[0].x; // 第一点的 X 分量
        y_m = sector1.triangle[loop_m].vertex[0].y; // 第一点的 Y 分量
        z_m = sector1.triangle[loop_m].vertex[0].z; // 第一点的 Z 分量
        u_m = sector1.triangle[loop_m].vertex[0].u; // 第一点的 U 纹理坐标
        v_m = sector1.triangle[loop_m].vertex[0].v; // 第一点的 V 纹理坐标
        glTexCoord2f(u_m,v_m); glVertex3f(x_m,y_m,z_m); // 设置纹理坐标和顶点

        x_m = sector1.triangle[loop_m].vertex[1].x; // 第二点的 X 分量
        y_m = sector1.triangle[loop_m].vertex[1].y; // 第二点的 Y 分量
        z_m = sector1.triangle[loop_m].vertex[1].z; // 第二点的 Z 分量
        u_m = sector1.triangle[loop_m].vertex[1].u; // 第二点的 U 纹理坐标
        v_m = sector1.triangle[loop_m].vertex[1].v; // 第二点的 V 纹理坐标
        glTexCoord2f(u_m,v_m); glVertex3f(x_m,y_m,z_m); // 设置纹理坐标和顶点

        x_m = sector1.triangle[loop_m].vertex[2].x; // 第三点的 X 分量
        y_m = sector1.triangle[loop_m].vertex[2].y; // 第三点的 Y 分量
        z_m = sector1.triangle[loop_m].vertex[2].z; // 第三点的 Z 分量
        u_m = sector1.triangle[loop_m].vertex[2].u; // 第二点的 U 纹理坐标
        v_m = sector1.triangle[loop_m].vertex[2].v; // 第二点的 V 纹理坐标
        glTexCoord2f(u_m,v_m); glVertex3f(x_m,y_m,z_m); // 设置纹理坐标和顶点
        glEnd();   // 三角形绘制结束
    }
    return TRUE;    // 返回
}
```

搞定！我们已经完成了自己的第一帧画面。这绝对算不上什么Quake，但咳...,我们绝对也不是Carmack或者Abrash。运行程序时，您可以按下F、B、
PgUp 和 PgDown 键来看看效果。PgUp /
PgDown简单的上下倾斜镜头。如果NeHe决定保留的话，程序中使用的纹理取自于我的学校ID证件上的照片，并且做了浮雕效果....:)。
现在您也许在考虑下一步该做什么。但还是不要考虑使用这些代码来实现完整的3D引擎，写这个程序的目的也并非如此。您也许希望您的游戏中不止存在一个Sector，尤其是实现类似入口这样的部分，您还可能需要使用多边形(超过3个顶点)。程序现在的代码实现允许载入多个Sector并剔除了背面(背向镜头不用绘制的多边形)。将来我会写个这样的教程，但这需要更多的数学知识基础。

# 第十一课 飘动的旗帜

这一课从第六课的代码开始，创建一个飘动的旗帜。我相信在这课结束的时候，你可以掌握纹理映射和混合操作。
大家好！对那些想知道我在这里作了些什么的朋友，您可以先按文章的末尾所列出的链接，下载我那毫无意义的演示（Demo）看看先！我是bosco，我将尽我所能教您来实现一个以正弦波方式运动的图象。这一课基于NeHe的教程第六课，当然您至少也应该学会了一至六课的知识。您需要下载源码压缩包，并将压缩包内带的data目录连其下的位图一起释放至您的代码目录下。或者使用您自己的位图，当然它的尺寸必须适合OpenGL纹理的要求。
　　在我们开始之前，先打开Visual C++（译者：我可是用的C++ Builder…）并在其他的#inlude之后，添加如下的代码。这将引入我们在程序中将要用到的复杂（译者：复杂吗？）数学函数sine和cosine。

```c
#include <math.h>   // 引入数学函数库中的Sin
```

我们将使用points数组来存放网格各顶点独立的x，y，z坐标。这里网格由45×45点形成，换句话说也就是由44格×44格的小方格子依次组成了。wiggle_count用来指定纹理波浪的运动速度。每3帧一次看起来很不错，变量hold将存放一个用来对旗形波浪进行光滑的浮点数。这几行添加在程序头部，位于最后一行#include之后、GLuint texture[1]之前的位置。

```c
float points[ 45 ][ 45 ][3];   // Points网格顶点数组
int wiggle_count = 0;   // 指定旗形波浪的运动速度
GLfloat hold;    // 临时变量
```

然后下移至LoadGLTextures()子过程。本课中使用的纹理文件名是Tim.bmp。找到LoadBMP("Data/NeHe.bmp")这一句，并用LoadBMP ("Data/Tim.bmp")替换它。

```c
if (TextureImage[0]=LoadBMP("Data/Tim.bmp")) // 载入位图
```

接着在InitGL()函数的尾部return TRUE之前，添加如下的代码。 

```c
glPolygonMode( GL_BACK, GL_FILL );  // 后表面完全填充
glPolygonMode( GL_FRONT, GL_LINE );  // 前表面使用线条绘制
```

上面的代码指定使用完全填充模式来填充多边形区域的背面（译者：或者叫做后表面吧）。相反，多边形的正面（译者：前表面）则使用轮廓线填充了。这些方式完全取决于您的个人喜好。并且与多边形的方位或者顶点的方向有关。详情请参考红宝书（Red Book）。这里我顺便推销一本推动我学习OpenGL的好书 — Addison-Wesley出版的《Programmer's Guide to OpenGL》。个人以为这是学习OpenGL的无价之宝。
接着上面的代码并在return TRUE这一句之前，添加如下的几行。

上面的代码指定使用完全填充模式来填充多边形区域的背面（译者：或者叫做后表面吧）。相反，多边形的正面（译者：前表面）则使用轮廓线填充了。这些方式完全取决于您的个人喜好。并且与多边形的方位或者顶点的方向有关。详情请参考红宝书（Red Book）。这里我顺便推销一本推动我学习OpenGL的好书 — Addison-Wesley出版的《Programmer's Guide to OpenGL》。个人以为这是学习OpenGL的无价之宝。
接着上面的代码并在return TRUE这一句之前，添加如下的几行。

  

```c
// 沿X平面循环
for(int x=0; x<45; x++)
{
    // 沿Y平面循环
    for(int y=0; y<45; y++)
    {
        // 向表面添加波浪效果
        points[x][y][0]=float((x/5.0f)-4.5f);
        points[x][y][1]=float((y/5.0f)-4.5f);
        points[x][y][2]=float(sin((((x/5.0f)*40.0f)/360.0f)*3.141592654*2.0f));
    }
}
```

这里感谢Graham Gibbons关于使用整数循环变量消除波浪间的脉冲锯齿的建议。

上面的两个循环初始化网格上的点。使用整数循环可以消除由于浮点运算取整造成的脉冲锯齿的出现。我们将x和y变量都除以5，再减去4.5。这样使得我们的波浪可以“居中”（译者：这样计算所得结果将落在区间[-4.5，4.5]之间）。

点[x][y][2]最后的值就是一个sine函数计算的结果。Sin()函数需要一个弧度参变量。将float_x乘以40.0f，得到角度值。然后除以360.0f再乘以PI，乘以2，就转换为弧度了。
接着我将彻底重写DrawGLScene函数。

```c
int DrawGLScene(GLvoid)   // 绘制我们的GL场景
{
    int x, y;   // 循环变量
    float float_x, float_y, float_xb, float_yb; // 用来将旗形的波浪分割成很小的四边形
```

我们使用不同的变量来控制循环。下面的代码中大多数变量除了用来控制循环和存储临时变量之外并没有什么别的用处。 

```c
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除屏幕和深度缓冲
    glLoadIdentity();   // 重置当前的模型观察矩阵

    glTranslatef(0.0f,0.0f,-12.0f);  // 移入屏幕12个单位

    glRotatef(xrot,1.0f,0.0f,0.0f);  // 绕 X 轴旋转
    glRotatef(yrot,0.0f,1.0f,0.0f);  // 绕 Y 轴旋转
    glRotatef(zrot,0.0f,0.0f,1.0f);  // 绕 Z 轴旋转

    glBindTexture(GL_TEXTURE_2D, texture[0]); // 选择纹理
```

正如您所见，上面的代码和第六课的很类似，唯一的区别就是我将场景挪的离镜头更远了一些。 

```c
    glBegin(GL_QUADS);   // 四边形绘制开始
    for( x = 0; x < 44; x++ )  // 沿 X 平面 0-44 循环(45点)
    {
        for( y = 0; y < 44; y++ )  // 沿 Y 平面 0-44 循环(45点)
        {
```

接着开始使用循环进行多边形绘制。这里使用整型可以避免我以前所用的int()强制类型转换。 

```c
            float_x = float(x)/44.0f; // 生成X浮点值
            float_y = float(y)/44.0f; // 生成Y浮点值
            float_xb = float(x+1)/44.0f; // X浮点值+0.0227f
            float_yb = float(y+1)/44.0f; // Y浮点值+0.0227f
```

上面我们使用4个变量来存放纹理坐标。每个多边形（网格之间的四边形）分别映射了纹理的1/44×1/44部分。循环首先确定左下顶点的值，然后我们据此得到其他三点的值。 

```c
            glTexCoord2f( float_x, float_y); // 第一个纹理坐标 (左下角)
            glVertex3f( points[x][y][0], points[x][y][1], points[x][y][2] );

            glTexCoord2f( float_x, float_yb ); // 第二个纹理坐标 (左上角)
            glVertex3f( points[x][y+1][0], points[x][y+1][1], points[x][y+1][2] );

            glTexCoord2f( float_xb, float_yb ); // 第三个纹理坐标 (右上角)
            glVertex3f( points[x+1][y+1][0], points[x+1][y+1][1], points[x+1][y+1][2] );

            glTexCoord2f( float_xb, float_y ); // 第四个纹理坐标 (右下角)
            glVertex3f( points[x+1][y][0], points[x+1][y][1], points[x+1][y][2] );
		}
	}
	glEnd();   // 四边形绘制结束
```

上面几行使用glTexCoord2f()和glVertex3f()载入数据。提醒一点：四边形是逆时针绘制的。这就是说，您开始所见到的表面是背面。后表面完全填充了，前表面由线条组成。

如果您按顺时针顺序绘制的话，您初始时见到的可能是前表面。也就是说您将看到网格型的纹理效果而不是完全填充的。

```c
    if( wiggle_count == 2 )   // 用来降低波浪速度(每隔2帧一次)
    {
```

每绘制两次场景，循环一次sine值，以产生运动效果。 

```c
        for( y = 0; y < 45; y++ )  // 沿Y平面循环
        {
            hold=points[0][y][2];  // 存储当前左侧波浪值
            for( x = 0; x < 44; x++) // 沿X平面循环
            {
                // 当前波浪值等于其右侧的波浪值
                points[x][y][2] = points[x+1][y][2];
            }
            points[44][y][2]=hold;  // 刚才的值成为最左侧的波浪值
        }
        wiggle_count = 0;  // 计数器清零
	}
	wiggle_count++;   // 计数器加一
```

上面所作的事情是先存储每一行的第一个值，然后将波浪左移一下，是图象产生波浪。存储的数值挪到末端以产生一个永无尽头的波浪纹理效果。然后重置计数器wiggle_count以保持动画的进行。

上面的代码由NeHe（2000年2月）修改过，以消除波浪间出现的细小锯齿。

```c
    xrot+=0.3f;   // X 轴旋转
    yrot+=0.2f;   // Y 轴旋转
    zrot+=0.4f;   // Z 轴旋转

    return TRUE;   // 返回
}
```


标准的NeHe旋转增量。现在编译并运行程序，您将看到一个漂亮的位图波浪。除了嘘声一片之外，我不敢确信大家的反应。但我希望大家能从这一课中学到点什么。如果您有任何问题或者需要澄清的地方，请随便联络我。感谢大家。

# 第十二课 显示列表

想知道如何加速你的OpenGL程序么？这一课将告诉你如何使用OpenGL的显示列表，它通过预编译OpenGL命令来加速你的程序，并可以为你省去很多重复的代码。
这次我将教你如何使用显示列表，显示列表将加快程序的速度，而且可以减少代码的长度。

当你在制作游戏里的小行星场景时，每一层上至少需要两个行星，你可以用OpenGL中的多边形来构造每一个行星。聪明点的做法是做一个循环，每个循环画出行星的一个面，最终你用几十条语句画出了一个行星。每次把行星画到屏幕上都是很困难的。当你面临更复杂的物体时你就会明白了。

那么，解决的办法是什么呢？用现实列表，你只需要一次性建立物体，你可以贴图，用颜色，想怎么弄就怎么弄。给现实列表一个名字，比如给小行星的显示列表命名为“asteroid”。现在，任何时候我想在屏幕上画出行星，我只需要调用glCallList(asteroid)。之前做好的小行星就会立刻显示在屏幕上了。因为小行星已经在显示列表里建造好了，OpenGL不会再计算如何构造它。它已经在内存中建造好了。这将大大降低CPU的使用，让你的程序跑的更快。

那么，开始学习咯。我称这个DEMO为Q-Bert显示列表。最终这个DEMO将在屏幕上画出15个立方体。每个立方体都由一个盒子和一个顶部构成，顶部是一个单独的显示列表，盒子没有顶。

这一课是建立在第六课的基础上的，我将重写大部分的代码，这样容易看懂。下面的这些代码在所有的课程中差不多都用到了。

下面设置变量。首先是存储纹理的变量，然后两个新的变量用于显示列表。这些变量是指向内存中显示列表的指针。命名为box和top。

然后用两个变量xloop,yloop表示屏幕上立方体的位置，两个变量xrot，yrot表示立方体的旋转。

```c
GLuint box;   // 保存盒子的显示列表
GLuint top;   // 保存盒子顶部的显示列表
GLuint xloop;   // X轴循环变量
GLuint yloop;   // Y轴循环变量
```

接下来建立两个颜色数组 

```c
static GLfloat boxcol[5][3]=  // 盒子的颜色数组
{
    // 亮:红，橙，黄，绿，蓝
    {1.0f,0.0f,0.0f},{1.0f,0.5f,0.0f},{1.0f,1.0f,0.0f},{0.0f,1.0f,0.0f},{0.0f,1.0f,1.0f}
};

static GLfloat topcol[5][3]=  // 顶部的颜色数组
{
    // 暗:红，橙，黄，绿，蓝
    {.5f,0.0f,0.0f},{0.5f,0.25f,0.0f},{0.5f,0.5f,0.0f},{0.0f,0.5f,0.0f},{0.0f,0.5f,0.5f}
};
```

现在正式开始建立显示列表。你可能注意到了，所有创造盒子的代码都在第一个显示列表里，所有创造顶部的代码都在另一个列表里。我会努力解释这些细节。

```c
GLvoid BuildLists()   // 创建盒子的显示列表
{
```

开始的时候我们告诉OpenGL我们要建立两个显示列表。glGenLists(2)建立了两个显示列表的空间，并返回第一个显示列表的指针。“box”指向第一个显示列表，任何时候调用“box”第一个显示列表就会显示出来。

```c
	box=glGenLists(2);  // 创建两个显示列表的名称
```


现在开始构造第一个显示列表。我们已经申请了两个显示列表的空间了，并且有box指针指向第一个显示列表。所以现在我们应该告诉OpenGL要建立什么类型的显示列表。

我们用glNewList()命令来做这个事情。你一定注意到了box是第一个参数，这表示OpenGL将把列表存储到box所指向的内存空间。第二个参数GL_COMPILE告诉OpenGL我们想预先在内存中构造这个列表，这样每次画的时候就不必重新计算怎么构造物体了。

GL_COMPILE类似于编程。在你写程序的时候，把它装载到编译器里，你每次运行程序都需要重新编译。而如果他已经编译成了.exe文件，那么每次你只需要点击那个.exe文件就可以运行它了，不需要编译。当OpenGL编译过显示列表后，就不需要再每次显示的时候重新编译它了。这就是为什么用显示列表可以加快速度。

```c
    glNewList(box,GL_COMPILE);  // 创建第一个显示列表
```

下面这部分的代码画出一个没有顶部的盒子，它不会出现在屏幕上，只会存储在显示列表里。

你可以在glNewList()和glEngList()中间加上任何你想加上的代码。可以设置颜色，贴图等等。唯一不能加进去的代码就是会改变显示列表的代码。显示列表一旦建立，你就不能改变它。

比如你想加上glColor3ub(rand()%255,rand()%255,rand()%255)，使得每一次画物体时都会有不同的颜色。但因为显示列表只会建立一次，所以每次画物体的时候颜色都不会改变。物体将会保持第一次建立显示列表时的颜色。 如果你想改变显示列表的颜色，你只有在调用显示列表之前改变颜色。后面将详细解释这一点。

```c
    glBegin(GL_QUADS);    // 开始绘制四边形
    // 底面
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    // 前面
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    // 后面
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    // 右面
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    // 左面
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glEnd();    // 四边形绘制结束
```

用glEngList()命令，我们告诉OpenGL我们已经完成了一个显示列表。在glNewList()和glEngList()之间的任何东西就是显示列表的一部分。

```c
    glEndList();     // 第一个显示列表结束
```

现在我们来建立第二个显示列表。在上一个显示列表的指针上加1，就得到了第二个显示列表的指针。第二个显示列表的指针命名为“top”。

```c
    top=box+1;     // 第二个显示列表的名称
```

现在我们知道了第二个显示列表的指针，我们可以建立它了。

```c
    glNewList(top,GL_COMPILE);    // 盒子顶部的显示列表
```

下面的代码画出盒子的顶部。 

```c
    glBegin(GL_QUADS);    // 开始绘制四边形
    // 上面
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    glEnd();    // 结束绘制四边形
```

然后告诉OpenGL第二个显示列表建立完毕。 

```c
	glEndList();     // 第二个显示列表创建完毕
}
```

贴图纹理的代码和之前教程里的代码是一样的。我们需要一个可以贴在立方体上的纹理。我决定使用mipmapping处理让纹理看上去光滑，因为我讨厌看见像素点。纹理的文件名是“cube.bmp”，存放在data目录下。

```c
if (TextureImage[0]=LoadBMP("Data/Cube.bmp")) 
```

改变窗口大小的代码和第六课是一样的。

改变窗口大小的代码和第六课是一样的。

初始化的代码只有一点改变，加入了一行BuildList()。请注意代码的顺序，先读入纹理，然后建立显示列表，这样当我们建立显示列表的时候就可以将纹理贴到立方体上了。

```c
    BuildLists();   // 创建显示列表
```

接下来的三行使灯光有效。Light0一般来说是在显卡中预先定义过的，如果Light0不工作，把下面那行注释掉好了。

最后一行的GL_COLOR_MATERIAL使我们可以用颜色来贴纹理。如果没有这行代码，纹理将始终保持原来的颜色，glColor3f(r,g,b)就没有用了。总之这行代码是很有用的。

```c
    glEnable(GL_LIGHT0);   // 使用默认的0号灯
    glEnable(GL_LIGHTING);   // 使用灯光
    glEnable(GL_COLOR_MATERIAL);  // 使用颜色材质
```

现在到了绘制代码的地方了，我们还是和以前一样，以清除背景颜色为开始。

接着把纹理绑定到立方体，我可以把这些代码加入到显示列表中，但我还是把它留在了显示列表外边，这样我可以随便设置纹理。

```c
int DrawGLScene(GLvoid)   // 绘制操作开始
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除背景颜色

    glBindTexture(GL_TEXTURE_2D, texture[0]); // 选择纹理
```

现在到了真正有趣的地方了。用一个循环，循环变量用于改变Y轴位置，在Y轴上画5个立方体，所以用从1到5的循环。

```c
    for (yloop=1;yloop<6;yloop++)  // 沿Y轴循环
    {
```

另外用一个循环，循环变量用于改变X轴位置。每行上的立方体数目取决于行数，所以循环方式如下。

```c
        for (xloop=0;xloop<yloop;xloop++) // 沿X轴循环
        {
```

重置模型变化矩阵 

```c
            glLoadIdentity();  // 重置模型变化矩阵
```

边的代码是移动和旋转当前坐标系到需要画出立方体的位置。（原文有很罗嗦的一大段，相信大家的数学功底都不错，就不翻译了）

```c
            // 设置盒子的位置
            glTranslatef(1.4f+(float(xloop)*2.8f)-(float(yloop)*1.4f),((6.0f-float(yloop))*2.4f)-7.0f,-20.0f);
            glRotatef(45.0f-(2.0f*yloop)+xrot,1.0f,0.0f,0.0f); 
            glRotatef(45.0f+yrot,0.0f,1.0f,0.0f); 
```

然后在正式画盒子之前设置颜色。每个盒子用不同的颜色。 

然后在正式画盒子之前设置颜色。每个盒子用不同的颜色。 

```c
            glColor3fv(boxcol[yloop-1]); 
```

好了，颜色设置好了。现在需要做的就是画出盒子。不用写出画多边形的代码，只需要用glCallList(box)命令调用显示列表。盒子将会用glColor3fv()所设置的颜色画出来。 

```c
            glCallList(box);  // 绘制盒子
```

然后用另外的颜色画顶部。搞定。 

```c
            glColor3fv(topcol[yloop-1]); // 选择顶部颜色
            glCallList(top);  // 绘制顶部
		}
	}
	return TRUE;   // 成功返回
}
```

下面的代码是键盘控制的一些东西 

```c
SwapBuffers(hDC);  // 交换缓存
if (keys[VK_LEFT])  // 左键是否按下
{
    yrot-=0.2f;  // 如果是，向左旋转
}
if (keys[VK_RIGHT])  // 右键是否按下
{
    yrot+=0.2f;  // 如果是向右旋转
}
if (keys[VK_UP])  // 上键是否按下
{
    xrot-=0.2f;  // 如果是向上旋转
}
if (keys[VK_DOWN])  // 下键是否按下
{
    xrot+=0.2f;  // 如果是向下旋转
}
```

=================以下原帖没有翻译，是我自己翻译的 不当之处，大家指教
如同以前的教程一样，确保标题的正确。

```c
        if (keys[VK_F1])  
            // Is F1 Being Pressed?
        {
            keys[VK_F1]=FALSE;  // If So Make Key FALSE
            KillGLWindow();  // Kill Our Current Window
            fullscreen=!fullscreen;  // Toggle Fullscreen / Windowed Mode
            // Recreate Our OpenGL Window
            if (!CreateGLWindow("NeHe's Display List Tutorial",640,480,16,fullscreen))
            {
                return 0;  // Quit If Window Was Not Created
            }
        }
    }
}
```

这节教程结束后想必你已经对显示列表是如何运行的、如何创建的以及如何把5它显示到屏幕上有了一个比较好的理解了，显示列表功能强大，不仅仅能够简化复杂工程的编码，还能提供一点额外的运行速度以保持较高的刷新率。

希望你能喜欢这节教程，如果你有什么问题或者感到什么问题不清楚，请发邮件告诉我。

# 第十三课 图像字体

这一课我们将创建一些基于2D图像的字体，它们可以缩放，但不能旋转，并且总是面向前方，但作为基本的显示来说，我想已经够了。

欢迎来到另一课教程，这次我将教你如何使用位图字体，也许你会对自己说：“在屏幕上显示文字有什么难的？”。但是你真正尝试过就会知道，它确实没那么容易。

当然，你可以载入一段美术程序，把文字写在一个图片上，再把这幅图片载入你的OpenGL程序中，打开混合选项，从而在屏幕上显示出文字。但是这种做法非常耗时。而且根据你选择的滤波类型，最终结果常常会显得很模糊，或者有很多马赛克。另外，除非你的图像包含一个Alpha通道，否则一旦绘制在屏幕上，那些文字就会不透明（与屏幕中的其它物体混合）。

如果你使用过记事本、微软的Word或者其它文字处理软件，你会注意到所有不同的字体都是可用的。这课就会教你如何在自己的OpenGL程序中使用和原样相同的字体。事实上，任何安装在你的计算机中的字体都可以使用在演示中（中文不行）。

使用位图字体比起使用图形字体（贴图）看起来不止强100倍。你可以随时改变显示在屏幕上的文字，而且用不着为它们逐个制作贴图。只需要将文字定位，再使用我最新的gl命令就可以在屏幕上显示文字了。

我尽可能试着将命令做的简单。你只需要敲入glPrint("Hello") 。它是那么简单。不管怎样，从这段长长的介绍就可以看出，我对这课教程是多么的满意。写这段代码大概花了我一个半小时，为什么这么长的时间呢？那是因为在使用位图字体方面完全没有可用的资料，除非你愿意使用MFC中的代码。为了使代码简单，我想，如果我把它全部重写为容易理解的C语言代码，那一定会好些 :)

一个小注释，这段代码是专门针对Windows写的，它使用了Windows的wgl函数来创建字体，显然，Apple机系统有agl，X系统有glx来支持做同样事情的，不幸的是，我不能保证这些代码也是容易使用的。如果那位有能在屏幕上显示文字且独立于平台的代码，请告诉我，我将重写一个有关字体的教程。

我们从第一课的典型代码开始，添加上stdio.h头文件以便进行标准输入/输出操作，另外，stdarg.h头文件用来解析文字以及把变量转换为文字。最后加上math.h头文件，这样我们就可以使用SIN和COS函数在屏幕中移动文字了。

```c
#include <stdarg.h> // 用来定义可变参数的头文件
```

另外，我们还要添加3个变量。base将保存我们创建的第一个显示列表的编号。每个字符都需要有自己的显示列表。例如，字符‘A’在显示列表中是65，‘B’是66，‘C’是67，等等。所以，字符‘A’应保存在显示列表中的base + 65这个位置。

然后添加两个计数器（cnt1 和 cnt2），它们采用不用的累加速度，通过SIN和COS函数来改变文字在屏幕上的位置。在屏幕上创造出一种看起来像是半随机的移动方式。同时，我们用这两个计数器来改变文字的颜色（后面会进一步解释）。

```c
GLuint base;  // 绘制字体的显示列表的开始位置
GLfloat cnt1;  // 字体移动计数器1
GLfloat cnt2;  // 字体移动计数器2
```

下面这段代码用来构建真实的字体，这也是最难写的一部分代码。‘HFONT font’告诉Windows我们将要使用一个Windows字体。Oldfont用来存放字体。
接下来我们在定义base的同时使用glGenLists(96)创建了一组共96个显示列表。

```c
GLvoid BuildFont(GLvoid)   // 创建位图字体
{
    HFONT font;   // 字体句柄
    HFONT oldfont;   // 旧的字体句柄

    base = glGenLists(96);   // 创建96个显示列表
```

下面该有趣的部分了，我们将创建属于自己的字体。我们从指定字体的大小开始，你会注意到它是一个负数，我们通过加上一个负号来告诉Windows寻找一个基于CHARACTER高度的字体。如果我们使用一个正数，就是寻找一个与基于CELL的高度相匹配的字体。

```c
    font = CreateFont( -24,   // 字体高度
```

然后我们指定每个单元的宽度，你会注意到我把它定义为0，这样，Windows就会使用默认值。如果你愿意的话，可以改变它的值，比如更宽一点，等等。 

```c
	0,  // 字体宽度
```

Angle Of Escapement会将字体旋转，它不是一个常用的属性，除了0，90，180，270四个角度以外，由于字体本身要适应其看不见的方形边框，常常会显的裁切不正。MSDN帮助中解释Orientation Angle用于指定每个字的底边和显示设备的X轴之间的角度，每个单位是十分之一个角度，不幸的是我对这个没有概念。

```c
    0,  // 字体的旋转角度 Angle Of Escapement
    0,  // 字体底线的旋转角度Orientation Angle
```

字体重量是一个很重要的参数，你可以设置一个0–1000之间的值或使用一个已定义的值。FW_DONTCARE是0, FW_NORMAL是400, FW_BOLD是700 and FW_BLACK是900。还有许多预先定义的值，但是这四个的效果比较好。值越大，字体就越粗。

```c
    FW_BOLD,  // 字体的重量
```


Italic(斜体),Underline(下划线)和Strikeout（删除线）可以是TRUE或FALSE。如果将Underline设置为TRUE，那么字体就会带有下划线，否则就没有，非常简单。

```c
    FALSE,  // 是否使用斜体
    FALSE,  // 是否使用下划线
    FALSE,  // 是否使用删除线
```

Character Set Identifier（字符集标识符）用来描述你要使用的字符集（内码）类型。有太多需要说明的类型了。CHINESEBIG5_CHARSET，GREEK_CHARSET，RUSSIAN_CHARSET，DEFAULT_CHARSET ,等等。我使用的是ANSI，尽管DEFAULT也是很好用的。
如果你有兴趣使用Webdings或Wingdings等字体，你必须使用SYMBOL_CHARSET而不是ANSI_CHARSET。

```c
    ANSI_CHARSET,  // 设置字符集
```

Output Precision（输出精度）非常重要。它告诉Windows在有多种字符集的情况下使用哪类字符集。OUT_TT_PRECIS告诉Windows如果一个名字对应多种不同的选择字体，那么选择字体的TRUETYPE类型。Truetype字体通常看起来要好些，尤其是你把它们放大的时候。你也可以使用OUT_TT_ONLY_PRECIS，它将会一直尝试使用一种TRUETYPE类型的字体

```c
    OUT_TT_PRECIS,  // 输出精度
```

裁剪精度是一种当字体落在裁剪范围之外时使用的剪辑类型，不用多说，只要把它设置为DEFAULT就可以了。

```c
    CLIP_DEFAULT_PRECIS, // 裁剪精度
```

输出质量非常重要。你可以使用PROOF，DRAFT，NONANTIALIASED，DEFAULT或ANTIALISED。
我们都知道，ANTIALIASED字体看起来很好，将一种字体Antialiasing(反锯齿)可以实现在Windows下打开字体平滑时同样的效果，它使任何东西看起来都要少些锯齿，也就是更平滑。 

```c
    ANTIALIASED_QUALITY, // 输出质量
```

下面是Family和Pitch设置。Pitch属性有DEFAULT_PITCH，FIXED_PITCH和VARIABLE_PITCH，Family有FF_DECORATIVE,FF_MODERN,FF_ROMAN,FF_SCRIPT,FF_SWISS,FF_DONTCARE.尝试一下这些值，你就会知道它们到底有什么功能。我把它们都设置为默认值。

```c
    FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch
```

最后，是我们需要的字体的确切的名字。打开Microsoft Word或其它什么文字处理软件，点击字体下拉菜单，找一个你喜欢的字体。将‘Courier New’替换为你想用的字体的名字，你就可以使用它了。（中文还不行，需要别的方法）

```c
    "Courier New");  // 字体名称
```

现在，选择我们刚才创建的字体。Oldfont将指向被选择的对象。然后我们从第32个字符（空格）开始建立96个显示列表。如果你愿意，也可以建立所有256个字符，只要确保使用glGenLists建立256个显示列表就可以了。然后我们将oldfont对象指针选入hDC并且删除font对象。 

```c
    oldfont = (HFONT)SelectObject(hDC, font);  // 选择我们需要的字体
    wglUseFontBitmaps(hDC, 32, 96, base);  // 创建96个显示列表，绘制从ASCII码为32-128的字符
    SelectObject(hDC, oldfont);   // 选择原来的字体
    DeleteObject(font);   // 删除字体
}
```

接下来的代码很简单。它在内存中从base开始删除96个显示列表。我不知道Windows是否会做这些工作，但还是保险为好。

```c
GLvoid KillFont(GLvoid)   // 删除显示列表
{
    glDeleteLists(base, 96);   //删除96个显示列表
}
```

下面就是我优异的GL文字程序了。你可以通过调用glPrint(“需要写的文字”)来调用这段代码。文字被存储在字符串 * fmt中。 

```c
GLvoid glPrint(const char *fmt, ...)   // 自定义GL输出字体函数
{
```

下面的第一行创建了一个大小为256个字符的字符数组，里面保存我们想要的文字串。第二行创建了一个指向一个变量列表的指针。我们在传递字符串的同时也传递了这个变量列表。如果我们传递文本时也传递了变量，这个指针将指向它们。 

```c
    char text[256];  // 保存文字串
    va_list ap;   // 指向一个变量列表的指针
```

下面两行代码检查是否有需要显示的内容，如果什么也没有，fmt就等于空（NULL），屏幕上也就什么都没有。

```c
    if (fmt == NULL)   // 如果无输入则返回
        return;  
```

接下来三行代码将文字中的所有符号转换为它们的字符编号。最后，文字和转换的符号被存储在一个叫做text的字符串中。以后我会多解释一些有关字符的细节。

接下来三行代码将文字中的所有符号转换为它们的字符编号。最后，文字和转换的符号被存储在一个叫做text的字符串中。以后我会多解释一些有关字符的细节。

  

```c
    va_start(ap, fmt);   // 分析可变参数
    vsprintf(text, fmt, ap);  // 把参数值写入字符串
    va_end(ap);   // 结束分析
```

然后我们将GL_LIST_BIT压入属性堆栈，它会防止glListBase影响到我们的程序中的其它显示列表。
GlListBase(base-32)是一条有些难解释的命令。比如说要写字母‘A’，它的相应编号为65。如果没有glListBase(base-32)命令，OpenGL就不知道到哪去找这个字母。它会在显示列表中的第65个位置找它，但是，假如base的值等于1000，那么‘A’的实际存放位置就是1065了。所以通过base设置一个起点，OpenGL就知道到哪去找到正确的显示列表了。减去32是因为我们没有构造过前32个显示列表，那么就跳过它们好了。于是，我们不得不通过从base的值减去32来让OpenGL知道这一点。我希望这些有意义。

```c
    glPushAttrib(GL_LIST_BIT);   // 把显示列表属性压入属性堆栈
    glListBase(base - 32);   // 设置显示列表的基础值
```

现在OpenGL知道字母的存放位置了，我们就可以让它在屏幕上显示文字了。GlCallLists是一个很有趣的命令。它可以同时将多个显示列表的内容显示在屏幕上。
下面的代码做后续工作。首先，它告诉OpenGL我们将要在屏幕上显示出显示列表中的内容。Strlen(text)函数用来计算我们将要显示在屏幕上的文字的长度。然后，OpenGL需要知道我们允许发送给它的列表的最大值。我们不能发送长度大于255的字符串。这个字符列表的参数被当作一个无符号字符数组处理，它们的值都介于0到255之间。最后，我们通过传递text(它指向我们的字符串)来告诉OpenGL显示的内容。

也许你想知道为什么字符不会彼此重叠堆积在一起。那时因为每个字符的显示列表都知道字符的右边缘在那里，在写完一个字符后，OpenGL自动移动到刚写过的字符的右边，在写下一个字或画下一个物体时就会从GL移动到的最后的位置开始，也就是最后一个字符的右边。

最后，我们将GL_LIST_BIT属性弹出堆栈，将GL恢复到我们使用glListBase(base-32)设置base那时的状态。

```c
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // 调用显示列表绘制字符串
    glPopAttrib();   // 弹出属性堆栈
}
```

在初始化代码中唯一的变化就是BuildFont()。它调用前面的代码来创建字体，然后OpenGL就可以使用这个字体了。 

```c
BuildFont();    // 创建字体
```

下面就是画图的代码了。我们从清除屏幕和深度缓存开始。我们调用glLoadIdentity()来重置所有东西。然后我们将坐标系向屏幕里移动一个单位。如果不移动的话无法显示出文字。当你使用透视投影而不是ortho投影的时候位图字体表现的更好。由于ortho看起来不好，所以我用透视投影，并移动坐标系。。
你会注意到如果把坐标系在屏幕里放的更深远，字体并不会想你想象的那样缩小，只是你可以在控制文字位置时有更多的选择。如果你将坐标系移入屏幕一个单位，你就可以字X轴上-0.5到+0.5的范围内调整文字的位置。如果深入10个单位的话，移动范围就从-5到+5。它给了你更多的选择来替代使用小数指定文字的精确位置。什么都不能改变文字的大小，即使是调用glScale(x,y,z)函数.如果你想改变字体的大小，只能在创建它的时候改变它。

```c
int DrawGLScene(GLvoid)   // 此过程中包括所有的绘制代码
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除屏幕及深度缓存
    glLoadIdentity();   // 重置当前的模型观察矩阵
    glTranslatef(0.0f,0.0f,-1.0f);  // 移入屏幕一个单位
```

下面我们使用一些奇妙的数学方法来产生颜色变化脉冲。如果你不懂我在做什么你也不必担心。我喜欢利用教多的变量和教简单的方法来达到我的目的。
这样，我使用那两个用来改变文字在屏幕上位置的计数器来改变红、绿、蓝这些颜色。红色值使用COS和计数器1在-1.0到1.0之间变化。绿色值使用SIN和计数器2也在-1.0到1.0之间变化。蓝色值使用COS和计数器1和2在0.5到1.5之间变化。于是，蓝色值就永远不会等于0，文字的颜色也永远不会消失。笨办法，但很管用。

```c
    // 根据字体位置设置颜色
    glColor3f(1.0f*float(cos(cnt1)),1.0f*float(sin(cnt2)),1.0f-0.5f*float(cos(cnt1+cnt2)));
```

下面是一个新命令。GlRasterPos2f(x,y)用于在屏幕上定位位图字体。屏幕的中心依然是（0，0），注意，这里没有Z轴位置。位图字体只使用X轴（左/右）和Y轴（上/下）。因为我们将坐标系移入屏幕一个单位，往左最大值为-0.5，往右最大值为+0.5。你会注意到我在X轴上向左移动了0.45个像素。它将文字移到屏幕的中心位置。否则，因为文字的起点就是屏幕的中心，会造成文字整体偏右。
计算文字位置的算法与设置文字颜色的算法差不多。它将文字在X轴的-0.50到-0.40的范围内移动（记住，我们从起点就减了0.45），这就保证文字始终能显示在屏幕内。由于使用COS和计数器1，所以文字左右摆动，使用SIN和计数器2在Y轴的-0.35到0.35范围内移动。

```c
    // 设置光栅化位置，即字体的位置
    glRasterPos2f(-0.45f+0.05f*float(cos(cnt1)), 0.35f*float(sin(cnt2)));
```

现在轮到我最满意的部分了。将真正的文字写到屏幕上。我试着把它做的非常简单，而且非常友好，便于使用。你会注意到它看起来像调用一个OpenGL的函数，有点类似C语言中的输出语句的风格。在屏幕上输出文字只需要调用glPrint(“你想写的文字”).它很容易。文字将精确的显示在屏幕上你指定的位置。
Shawn T.发给我修改过的代码允许glPrint传递变量到屏幕。这意味着你可以增加一个计数器，并且在屏幕上显示出这个计数器的值，它是这样工作的。。。在下一行你看到：要显示的普通文字，然后有一个空格，一个破折号，一个空格，然后是一个“符号”(%7.2f)（C语言中的输出格式控制字）.现在你会看着%7.2说这是什么意思。它其实很简单，%是一个记号，表示不要把7.2f本身显示在屏幕上，因为它代表一个变量。7表示小数点左边最多有7位数字。然后是小数部分，小数点右边的2表示小数点右边最多保留两位小数。最后，f表示我们想要显示的数字类型为浮点型。我们想在屏幕上显示计数器1的值。比如，计数器1的值为300.12345f，那么在屏幕上显示的数字就是300.12，小数部分的3，4，5会舍去。因为我们只需要显示小数点后面两位数字。

我知道如果你是一个有经验的C程序员，这是个很基础的问题。不过也许也有人没有用过pringf函数。如果你想了解更多的字符，那就买本书或者查阅MSDN。

```c
    glPrint("Active OpenGL Text With NeHe - %7.2f", cnt1); // 输出文字到屏幕
```

最后一件事就是以不同的速率增加计数器的值来产生颜色脉冲并且移动文字。 

```c
    cnt1+=0.051f;   // 增加计数器值
    cnt2+=0.005f;   // 增加计数器值
    return TRUE;   // 继续运行
}
```

最后，如下所示，就是增加在KillGLWindow()函数中增加KillFont()函数，这很重要，它在我们退出程序之前做清理工作。

```c
KillFont();    // 删除字体
```


好了，用于使用位图字体的所有一切都在你的OpenGL程序中了。我在网上寻找过与这篇教程相似的文章，但没有找到。或许我的网站是第一个涉及这个主题的C代码的网站吧。不管怎样，享用这篇教程，快乐编码！

# 第十四课 图形字体

在一课我们将教你绘制3D的图形字体，它们可像一般的3D模型一样被变换。

这节课继续上一节课课的内容。在第13课我们学习了如何使用位图字体，这节课，我们将学习如何使用轮廓字体。
创建轮廓字体的方法类似于在第13课中我们创建位图字体的方法。但是，轮廓字体看起来要酷100倍！你可以指定轮廓字体的大小。轮廓字体可以在屏幕中以3D方式运动，而且轮廓字体还可以有一定的厚度！而不是平面的2D字符。使用轮廓字体，你可以将你的计算机中的任何字体转换为OpenGL中的3D字体，加上合适的法线，在有光照的时候，字符就会被很好的照亮了。

一个小注释，这段代码是专门针对Windows写的，它使用了Windows的wgl函数来创建字体，显然，Apple机系统有agl，X系统有glx来支持做同样事情的，不幸的是，我不能保证这些代码也是容易使用的。如果哪位有能在屏幕上显示文字且独立于平台的代码，请告诉我，我将重写一个有关字体的教程。

我们从第一课的典型代码开始，添加上stdio.h头文件以便进行标准输入/输出操作，另外，stdarg.h头文件用来解析文字以及把变量转换为文字。最后加上math.h头文件，这样我们就可以使用SIN和COS函数在屏幕中移动文字了。

另外，我们还要添加2个变量。base将保存我们创建的第一个显示列表的编号。每个字符都需要有自己的显示列表。例如，字符‘A’在显示列表中是65，‘B’是66，‘C’是67，等等。所以，字符‘A’应保存在显示列表中的base + 65这个位置。
我们再添加一个叫做rot的变量。用它配合SIN和COS函数在屏幕上旋转文字。我们同时用它来改变文字的颜色。

```c
GLuint base;  // 绘制字体的显示列表的开始位置
GLfloat rot;  // 旋转字体
```

GLYPHMETRICSFLOAT gmf[256]用来保存256个轮廓字体显示列表中对应的每一个列表的位置和方向的信息。我们通过gmf[num]来选择字母。num就是我们想要了解的显示列表的编号。在稍后的代码中，我将说明如何如何检查每个字符的宽度，以便自动将文字定位在屏幕中心。切记，每个字符的宽度可以不相同。Glyphmetrics会大大简化我们的工作。 

```c
GLYPHMETRICSFLOAT gmf[256]; // 记录256个字符的信息
```


下面这段用来构建真正的字体的代码类似于我们创建位图字体的方法。和13课一样，只是使用wglUseFontOutlines函数替换wglUseFontBitmaps函数。

```c
base = glGenLists(256);   // 创建256个显示列表 
wglUseFontOutlines( hDC,   // 设置当前窗口设备描述表的句柄
                   0,  // 用于创建显示列表字体的第一个字符的ASCII值
                   255,  // 字符数
                   base,  // 第一个显示列表的名称
```

That's not all however. We then set the deviation level. The closer to 0.0f, the smooth the font will look. After we set the deviation, we get to set the font thickness. This describes how thick the font is on the Z axis. 0.0f will produce a flat 2D looking font and 1.0f will produce a font with some depth.

The parameter WGL_FONT_POLYGONS tells OpenGL to create a solid font using polygons. If we use WGL_FONT_LINES instead, the font will be wireframe (made of lines). It's also important to note that if you use GL_FONT_LINES, normals will not be generated so lighting will not work properly.

The last parameter gmf points to the address buffer for the display list data.  

```c
    0.0f,  // 字体的光滑度，越小越光滑，0.0为最光滑的状态
    0.2f,  // 在z方向突出的距离
    WGL_FONT_POLYGONS,  // 使用多边形来生成字符，每个顶点具有独立的法线
    gmf);  //一个接收字形度量数据的数组的地址，每个数组元素用它对应的显示列表字符的数据填充
}
```

The following code is pretty simple. It deletes the 256 display lists from memory starting at the first list specified by base. I'm not sure if Windows would do this for you, but it's better to be safe than sorry :)  

```c
GLvoid KillFont(GLvoid)   // 删除显示列表
{
    glDeleteLists(base, 256);   // 删除256个显示列表
}
```

下面就是我优异的GL文字程序了。你可以通过调用glPrint(“需要写的文字”)来调用这段代码。文字被存储在字符串text[]中。 

```c
GLvoid glPrint(const char *fmt, ...)   // 自定义GL输出字体函数
{
```

下面的第一行定义了一个叫做length的变量。我们使用这个变量来查询字符串的长度。第二行创建了一个大小为256个字符的字符数组，里面保存我们想要的文字串。第三行创建了一个指向一个变量列表的指针，我们在传递字符串的同时也传递了这个变量列表。如果我们传递文字时也传递了变量，这个指针将指向它们。 

```c
    float length=0;   // 查询字符串的长度
    char text[256];  // 保存我们想要的文字串
    va_list ap;   // 指向一个变量列表的指针
```

下面两行代码检查是否有需要显示的内容，如果什么也没有，屏幕上也就什么都没有。

```c
    if (fmt == NULL)   // 如果无输入则返回
        return; 
```

接下来三行代码将文字中的所有符号转换为它们的字符编号。最后，文字和转换的符号被存储在一个叫做“text”的字符串中。以后我会多解释一些有关字符的细节。 

接下来三行代码将文字中的所有符号转换为它们的字符编号。最后，文字和转换的符号被存储在一个叫做“text”的字符串中。以后我会多解释一些有关字符的细节。 

```c
    va_start(ap, fmt);   // 分析可变参数
    vsprintf(text, fmt, ap);  // 把参数值写入字符串
    va_end(ap);   // 结束分析
```

感谢Jim Williams对下面一段代码的建议。以前我是用手工将文字置于中心的，而他的办法要好的多。
我们从一个循环开始，它将逐个检查文本中的字符。我们通过strlen(text)得到文本的长度。设置好了循环以后，我们将通过加上每个字符的长度来增加length的值。当循环结束以后，被保存在length中的值就是整个字符串的长度。所以，如果我们要写的是“hello”，假设每个字符的长度都为10个单位，我们先给length的值加上第一个字母的长度10。然后，我们检查第二个字母的长度，它的长度也是10，所以length就变成10 + 10（20）。当我们检查完所有5个字母以后，length的值就会等于50（5 *10）。

给出我们每个字符的长度的代码是gmf[text[loop]].gmfCellIncX。记住，gmf存储了我们每个显示列表的信息。如果loop等于0，text[loop]就是我们的字符串中的第一个字符。如果loop等于1，text[loop]就是我们的字符串中的第二个字符。gmfCellIncX告诉我们被选择的字符的长度。GmfCellIncX表示显示位置从已绘制上的上一个字符向右移动的真正距离，这样，字符之间就不会重叠在一起。同时，这个距离就是我们想得到的字符的宽度。你还可以通过gmfCelllncY命令来得到字符的高度。如果你是在垂直方向绘制文本而不是在水平方向时，这会很方便。

```c
    for (unsigned int loop=0;loop<(strlen(text));loop++) // 查找整个字符串的长度
    {
        length+=gmf[text[loop]].gmfCellIncX; 
    }
```

最后我们取出计算后得到的length，并把它变成负数（因为我们要将文本从屏幕中心左移从而把整个文本置于屏幕中间）。然后我们把length除以2。我们并不想移动整个文本的长度，只需要一半！ 

```c
    glTranslatef(-length/2,0.0f,0.0f);  // 把字符串置于最左边
```

然后我们将GL_LIST_BIT压入属性堆栈，它会防止glListBase影响到我们的程序中的其它显示列表 

```c
    glPushAttrib(GL_LIST_BIT);  // 把显示列表属性压入属性堆栈
    glListBase(base);   // 设置显示列表的基础值为0
```

现在OpenGL知道字符的存放位置了，我们就可以让它在屏幕上显示文字了。GlCallLists会调用多个显示列表从而把整个文字的内容同时显示在屏幕上。
下面的代码做后续工作。首先，它告诉OpenGL我们将要在屏幕上显示出显示列表中的内容。Strlen(text)函数用来计算我们将要显示在屏幕上的文字的长度。然后，OpenGL需要知道我们允许发送给它的列表的最大值。我们依然不能发送长度大于255的字符串。所以我们使用UNSIGNED_BYTE。（用0 - 255来表示我们需要的字符）。最后，我们通过传递字符串文字告诉OpenGL显示什么内容。

也许你想知道为什么字符不会彼此重叠堆积在一起。那时因为每个字符的显示列表都知道字符的右边缘在那里，在写完一个字符后，OpenGL自动移动到刚写过的字符的右边，在写下一个字或画下一个物体时就会从GL移动到的最后的位置开始，也就是最后一个字符的右边。

最后，我们将GL_LIST_BIT属性弹出堆栈，将GL恢复到我们使用glListBase(base)设置base之前的状态。

```c
    glCallLists(strlen(text), GL_UNSIGNED_BYTE, text); // 调用显示列表绘制字符串
    glPopAttrib();   // 弹出属性堆栈
}
```

下面就是画图的代码了。我们从清除屏幕和深度缓存开始。我们调用glLoadIdentity()来重置所有东西。然后我们将坐标系向屏幕里移动十个单位。轮廓字体在透视图模式下表现非常好。你将文字移入屏幕越深，文字开起来就更小。文字离你越近，它看起来就更大。
也可以使用glScalef(x,y,z)命令来操作轮廓字体。如果你想把字体放大两倍，可以使用glScalef(1.0f,2.0f,1.0f). 2.0f 作用在y轴， 它告诉OpenGL将显示列表的高度绘制为原来的两倍。如果2.0f作用在x轴，那么文本的宽度将变成原来的两倍。

```c
int DrawGLScene(GLvoid)   // 此过程中包括所有的绘制代码
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // 清除屏幕及深度缓存
    glLoadIdentity();   // 重置当前的模型观察矩阵
    glTranslatef(0.0f,0.0f,-10.0f);  // 移入屏幕一个单位
```

在向屏幕里移动以后，我们希望文本能旋转起来。下面3行代码用来在3个轴上旋转屏幕。我将rot乘以不同的数，以便每个方向上的旋转速度不同。 

```c
    glRotatef(rot,1.0f,0.0f,0.0f);  // 沿X轴旋转
    glRotatef(rot*1.5f,0.0f,1.0f,0.0f);  // 沿Y轴旋转
    glRotatef(rot*1.4f,0.0f,0.0f,1.0f);  // 沿Z轴旋转
```

下面是令人兴奋的颜色循环了。照常，我们使用唯一递增的变量（rot）。颜色通过使用COS和SIN来循环变化。我将rot除以不同的数，这样每种颜色会以不同的速度递增。最终的效果非常好。

```c
    // 根据字体位置设置颜色
    glColor3f(1.0f*float(cos(rot/20.0f)),1.0f*float(sin(rot/25.0f)),1.0f-0.5f*float(cos(rot/17.0f)));
```

我最喜欢的部分，将文字写到屏幕上。我使用同将位图字体写到屏幕上相同的函数。将文字写在屏幕上，所有你要做的就是glPrint(“你想写的文字”)。很简单。
在下面的代码中，我们要写的是NeHe，空格，破折号，空格，然后是rot的值除以50后的结果（为了减慢计数器）。如果这个数大于999.99,左边第四个数将被去掉（我们要求只显示小数点左边3位数字）。只显示小数点右边的两位数字。

```c
    glPrint("NeHe - %3.2f",rot/50);  // 输出文字到屏幕
```

然后增大旋转变量从而改变颜色并旋转文字。 

```c
    rot+=0.5f;   // 增加旋转变量
    return TRUE;   // 成功返回
}
```

在这节课结束的时候，你应该已经学会在你的OpenGL程序中使用轮廓字体了。就像第13课，我曾在网上寻找一篇与这一课相似的教程，但是也没有找到。或许我的网站是第一个涉及这个主题同时又把它解释的简单易懂的C代码的网站吧。享用这篇教程，快乐编码！

# 第十五课  图形字体的纹理映射

这一课，我们将在上一课的基础上创建带有纹理的字体，它真的很简单。

在发布了前两篇关于位图字体和轮廓字体的教程以后，我收到很多邮件，很多读者都想知道如何才能给字体赋予纹理贴图。你可以使用自动纹理坐标生成器。它会为字体上的每一个多边形生成纹理坐标。
一个小注释，这段代码是专门针对Windows写的，它使用了Windows的wgl函数来创建字体，显然，Apple机系统有agl，X系统有glx来支持做同样事情的，不幸的是，我不能保证这些代码也是容易使用的。如果哪位有能在屏幕上显示文字且独立于平台的代码，请告诉我，我将重写一个有关字体的教程。

我们将使用第14课的代码来创作纹理字体的演示。如果程序中哪部分的代码有变化，我会重写那部分的所有代码以便看出我做的改动。

我们还要添加一个叫做texture[]的整型变量。它用于保存纹理。后面3行是第14课中的代码，本课不做改动。

下面的部分做了一些小改动。我打算在这课使用wingdings字体来显示一个海盗旗（骷髅头和十字骨头）的标志。如果你想显示文字的话，就不用改动第14课中的代码了，也可以选择另一种字体。
有些人想知道如何使用wingdings字体，这也是我不用标准字体的一个原因。wingdings是一种符号字体，使用它时需要做一些改动。告诉Windows使用wingdings字体并不太简单。如果你把字体的名字改为wingdings，你会注意到字体其实并没有选到。你必须告诉Windows这种字体是一种符号字体而不是一种标准字符字体。后面会继续解释。

```c
GLvoid BuildFont(GLvoid)   // 创建位图字体
{
    GLYPHMETRICSFLOAT gmf[256];   // 记录256个字符的信息
    HFONT font;   // 字体句柄

    base = glGenLists(256);   // 创建256个显示列表
    font = CreateFont( -12,   // 字体高度
                      0,  // 字体宽度
                      0,  // 字体的旋转角度 Angle Of Escapement
                      0,  // 字体底线的旋转角度Orientation Angle
                      FW_BOLD,  // 字体的重量
                      FALSE,  // 是否使用斜体
                      FALSE,  // 是否使用下划线
                      FALSE,  // 是否使用删除线
```


这就是有魔力的那一行！不使用第14课中的ANSI_CHARSET，我们将使用SYMBOL_CHARSET。这会告诉Windows我们创建的字体并不是由标准字符组成的典型字体。所谓符号字体通常是由一些小图片（符号）组成的。如果你忘了改变这行，wingdings,webdings以及你想用的其它符号字体就不会工作。

```c
                    SYMBOL_CHARSET,  // 设置字符集
```

下面几行没有变化。

```c
                    OUT_TT_PRECIS,  // 输出精度
                    CLIP_DEFAULT_PRECIS, // 裁剪精度
                    ANTIALIASED_QUALITY, // 输出质量
                    FF_DONTCARE|DEFAULT_PITCH, // Family And Pitch
```

既然我们已经选择了符号字符集标识符，我们就可以选择wingdings字体了 

```c
                    "Wingdings");  // 字体名称
```

剩下几行代码没有变化 

```c
SelectObject(hDC, font);   // 选择创建的字体

wglUseFontOutlines( hDC,  // 设置当前窗口设备描述表的句柄
                   0,  // 用于创建显示列表字体的第一个字符的ASCII值
                   255,  // 字符数
                   base,  // 第一个显示列表的名称
```

我们允许有更多的误差，这意味着GL不会严格的遵守字体的轮廓线。如果你把误差设置为0.0f，你就会发现严格地在曲面上贴图存在一些问题。但是如果你允许一定的误差，很多问题都可以避免。

```c
                    0.1f,  // 字体的光滑度，越小越光滑，0.0为最光滑的状态
```

下面三行代码还是相同的 

```c
                    0.2f,  // 在z方向突出的距离
                    WGL_FONT_POLYGONS,  // 使用多边形来生成字符，每个顶点具有独立的法线
                    gmf);  // 一个接收字形度量数据的数组的地址，每个数组元素用它对应的显示列表字符的数据填充
				}
```

在ReSizeGLScene()函数之前，我们要加上下面一段代码来读取纹理。你可能会认得这些前几课中的代码。我们创建一个保存位图的地方，读取位图，告诉Windows生成一个纹理，并把它保存在texture[0]中。
我们创建一种细化纹理（mipmapped texture），这样会看起来好些。纹理的名字叫做lights.bmp。

```c
if (TextureImage[0]=LoadBMP("Data/Lights.bmp"))  // 载入位图
```

下面四行代码将为我们绘制在屏幕上的任何物体自动生成纹理坐标。函数glTexGen非常强大，而且复杂，如果要完全讲清楚它的数学原理需要再写一篇教程。不过，你只要知道GL_S和GL_T是纹理坐标就可以了。默认状态下，它被设置为提取物体此刻在屏幕上的x坐标和y坐标，并把它们转换为顶点坐标。你会发现到物体在z平面没有纹理，只显示一些斑纹。正面和反面都被赋予了纹理，这些都是由glTexGen函数产生的。(X(GL_S)用于从左到右映射纹理，Y(GL_T)用于从上到下映射纹理。
GL_TEXTURE_GEN_MODE允许我们选择我们想在S和T纹理坐标上使用的纹理映射模式。你有3种选择：

- GL_EYE_LINEAR - 纹理会固定在屏幕上。它永远不会移动。物体将被赋予处于它通过的地区的那一块纹理。
- GL_OBJECT_LINEAR - 这种就是我们使用的模式。纹理被固定于在屏幕上运动的物体上。
- GL_SPHERE_MAP - 每个人都喜欢。创建一种有金属质感的物体。

```c
// 设置纹理映射模式
glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
glEnable(GL_TEXTURE_GEN_S);  // 使用自动生成纹理
glEnable(GL_TEXTURE_GEN_T); 
```


在InitGL()的最后有几行新代码。BuildFont()被放到了读取纹理的代码之后。glEnable(GL_COLOR_MATERIAL) 这行被删掉了，如果你想使用glColor3f(r,g,b)来改变纹理的颜色，那么就把glEnable(GL_COLOR_MATERIAL)这行重新加到这部分代码中。 

```c
int InitGL(GLvoid)    // 此处开始对OpenGL进行所有设置
{
    if (!LoadGLTextures())   // 载入纹理
    {
        return FALSE;   // 失败则返回
    }
    BuildFont();   // 创建字体显示列表

    glShadeModel(GL_SMOOTH);   // 启用阴影平滑
    glClearColor(0.0f, 0.0f, 0.0f, 0.5f);  // 黑色背景
    glClearDepth(1.0f);   // 设置深度缓存
    glEnable(GL_DEPTH_TEST);   // 启用深度测试
    glDepthFunc(GL_LEQUAL);   // 所作深度测试的类型
    glEnable(GL_LIGHT0);   // 使用第0号灯
    glEnable(GL_LIGHTING);   // 使用光照
    glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST); // 告诉系统对透视进行修正
```

启动2D纹理映射，并选择第一个纹理。这样就把第一个纹理映射到我们绘制在屏幕上的3D物体上了。如果你想加入更多的操作，可以按自己的意愿启动或禁用纹理映射。 

```c
    glEnable(GL_TEXTURE_2D);   // 使用二维纹理
    glBindTexture(GL_TEXTURE_2D, texture[0]);  // 选择使用的纹理
    return TRUE;   // 初始化成功
}
```

重置大小的代码没有变化，但DrawGLScene这部分代码有变化。 
这里是第一处变动。我们打算使用COS和SIN让物体绕着屏幕旋转而不是把它固定在屏幕中间。我们将把物体向屏幕里移动3个单位。在x轴，我们将移动范围限制在-1.1到+1.1之间。我们使用rot变量来控制左右移动。我们把上下移动的范围限制在+0.8到-0.8之间。同样使用rot变量来控制上下移动（最好充分利用你的变量）。 

```c
// 设置字体的位置
glTranslatef(1.1f*float(cos(rot/16.0f)),0.8f*float(sin(rot/20.0f)),-3.0f);
```

下面做常规的旋转。这会使符号在X，Y和Z轴旋转。 

```c
glRotatef(rot,1.0f,0.0f,0.0f);  // 沿X轴旋转
glRotatef(rot*1.2f,0.0f,1.0f,0.0f);  // 沿Y轴旋转
glRotatef(rot*1.4f,0.0f,0.0f,1.0f);  // 沿Z轴旋转
```

我们将物体相对观察点向左向下移动一点，以便于把符号定位于每个轴的中心。否则，当我们旋转它的时候，看起来就不像是在围绕它自己的中心在旋转。-0.35只是一个能让符号正确显示的数。我也试过一些其它数，因为我不知道这种字体的宽度是多少，可以适情况作出调整。我不知道为什么这种字体没有一个中心。 

```c
glTranslatef(-0.35f,-0.35f,0.1f);  // 移动到可以显示的位置
```

最后，我们绘制海盗旗的符号，然后增加rot变量，从而使这个符号在屏幕中旋转和移动。如果你不知道我是如何从字母‘N’中得到海盗旗符号的，那就打开Microsoft Word或是写字板。在字体下拉菜单中选择Wingdings字体。输入大写字母‘N’，就会显示出海盗旗符号了。 

```c
glPrint("N");   // 绘制海盗旗符号
rot+=0.1f;   // 增加旋转变量
```


最后要做的事就是在KillGLWindow()的最后添加KillFont()函数，如下所示。添加这行代码很重要。它将在我们退出程序之前做清理工作。

尽管我没有讲的细致入微，但我想你应该很好的理解了如何让OpenGL为你生成纹理坐标。在给你的字体或者是同类物体赋予纹理映射时，应该没有问题了，而且只需要改变两行代码，你就可以启用球体映射了，它的效果简直酷毙了！

# 第十六课 雾

这一课是基于第7课的代码的，你将学会三种不同的雾的计算方法，以及怎样设置雾的颜色和雾的范围。

这篇教程由Chris Aliotta编写。
你想给你的OpenGL程序添加雾效?我将在这篇教程中教你如何去做。这是我第一次写教程，我也只是OpenGL/C++编程的新手，所以如果你发现了什么错误请告诉我而不是叱责我。本课的代码基于第七课的代码编写。

Data Setup:

我们将从设置保存雾的信息的变量开始。变量fogMode用来保存三种类型的雾:GL_EXP,GL_EXP2和GL_LINEAR。我将在稍后解释这三种类型的区别。这些变量位于程序开头GLuint texture[3]这行后。变量fogfilter将用来表示我们使用的是哪种雾类型。变量fogColor保存雾的颜色。在程序的顶部我还加了一个布尔类型的变量gp用来记录'g'键是否被按下。

```c
bool  gp;   // G健是否按下
GLuint filter;   // 使用哪一个纹理过滤器
GLuint fogMode[]= { GL_EXP, GL_EXP2, GL_LINEAR }; // 雾气的模式
GLuint fogfilter= 0;   // 使用哪一种雾气
GLfloat fogColor[4]= {0.5f, 0.5f, 0.5f, 1.0f}; // 雾的颜色设为白色
```

现在我们已经设置了变量，接下来我们来看InitGL函数。为了获得更好的效果，glClearColor()这行已经被修改为将屏幕清为同雾相同的颜色。使用雾效只需很少的代码。总之你将发现这很容易。 

```c
glClearColor(0.5f,0.5f,0.5f,1.0f);  // 设置背景的颜色为雾气的颜色

glFogi(GL_FOG_MODE, fogMode[fogfilter]); // 设置雾气的模式
glFogfv(GL_FOG_COLOR, fogColor);  // 设置雾的颜色
glFogf(GL_FOG_DENSITY, 0.35f);  // 设置雾的密度
glHint(GL_FOG_HINT, GL_DONT_CARE);  // 设置系统如何计算雾气
glFogf(GL_FOG_START, 1.0f);  // 雾气的开始位置
glFogf(GL_FOG_END, 5.0f);  // 雾气的结束位置
glEnable(GL_FOG);   // 使用雾气
```

让我们先看看这段代码的头三行。第一行glEnable(GL_FOG);(?这应该是最后一行)不用再解释了吧，主要是初始化雾效。

第二行glFogi(GL_FOG_MODE, fogMode[fogfilter]);建立雾的过滤模式。之前我们声明了数组fogMode，它保存了值GL_EXP, GL_EXP2, and GL_LINEAR。现在是使用他们的时候了。我来解释它们（具体见红皮书，其实这是计算雾效混合因子的三种方式）：
GL_EXP - 充满整个屏幕的基本渲染的雾。它能在较老的PC上工作，因此并不是特别像雾。
GL_EXP2 - 比GL_EXP更进一步。它也是充满整个屏幕，但它使屏幕看起来更有深度。
GL_LINEAR - 最好的渲染模式。物体淡入淡出的效果更自然。

第三行glFogfv(GL_FOG_COLOR, fogcolor);设置雾的颜色。之前我们已将变量fogcolor设为(0.5f,0.5f,0.5f,1.0f)，这是一个很棒的灰色。

接下来我们看看最后的四行。glFogf(GL_FOG_DENSITY, 0.35f);这行设置雾的密度。增加数字会让雾更密，减少它则雾更稀。

glHint (GL_FOG_HINT, GL_DONT_CARE); 设置修正。我使用了GL_DONT_CARE因为我不关心它的值。

Eric Desrosiers Adds:关于glHint(GL_FOG_HINT, hintval);的解释

gl_dont_care - 由OpenGL决定使用何种雾效（对每个顶点还是每个像素执行雾效计算）和一个未知的公式（?）
gl_nicest - 对每个像素执行雾效计算（效果好）
gl_fastest - 对每个顶点执行雾效计算 （更快，但效果不如上面的好）

下一行glFogf(GL_FOG_START, 1.0f);设定雾效距屏幕多近开始。你可以根据你的需要随意改变这个值。下一行类似，glFogf(GL_FOG_END, 5.0f);告诉OpenGL程序雾效持续到距屏幕多远。

现在我们建立了绘制雾的代码，我们将加入键盘指令在不同的雾效模式间循环。这段代码及其它的按键处理代码在程序的最后。

```c
if (keys['G'] && !gp)   // G键是否 按下
{
    gp=TRUE;   // 是
    fogfilter+=1;   // 变换雾气模式
    if (fogfilter>2)   // 模式是否大于2
    {
        fogfilter=0;  // 置零
    }
    glFogi (GL_FOG_MODE, fogMode[fogfilter]); // 设置雾气模式
}
if (!keys['G'])   // G键是否释放
{
    gp=FALSE;   // 是，设置为释放
}
```


就是这样！大功告成！现在你的OpenGl程序有了雾效。

# 第十七课 2D 图像文字

在这一课中，你将学会如何使用四边形纹理贴图把文字显示在屏幕上。你将学会如何把256个不同的文字从一个256x256的纹理图像中分别提取出来，并为每一个文字创建一个显示列表，接着创建一个输出函数来创建任意你希望的文字。

本教程由NeHe和Giuseppe D'Agata提供。
我知道每个人都或许厌恶字体。目前为止我写的文字教程不仅能显示文字，还能显示3D文字，有纹理贴图的文字，以及处理变量。但是当你将你的作品移植到不支持位图或是轮廓字体的机器上会发生什么事呢？

由于Giuseppe D'Agata我们有了另一篇字体教程。你还会问什么？如果你记得在第一篇字体教程中我提到使用纹理在屏幕上绘制文字。通常当你使用纹理绘制文字时你会调用你最喜欢的图像处理程序，选择一种字体，然后输入你想显示的文字或段落。然后你保存位图并把它作为纹理读入到你的程序里。对一个需要很多文字或是文字在不停变化的程序来说这么做效率并不高。

本教程只使用有一个纹理来显示任意256个不同的字符。记住平均一个字符只有16个像素宽，大概16个像素高。如果你使用标准的256x256的纹理那么很明显你可以放入交叉的16个文字（即一个X），且最多16行16列。如果你需要一个更详细的解释：纹理是256个像素宽，一个字符是16个像素宽，256除以16得16:)

现在让我们来创建一个2D纹理字体demo！这课的程序基于第一课的代码。在程序的第一段，我们包括数学（math）和标准输入输出库（stdio）。我们需要数学库来使用正弦和余弦函数在屏幕上移动我们的文字，我们需要标准输入输出库来保证在我们制作纹理前要使用的位图实际存在。

我们将要加入一个变量base来指向我们的显示列表。我们还加入texture[2]来保存我们将要创建的两个纹理。Texture 1将是字体纹理，texture 2将是用来创建简单3D物体的凹凸纹理。
我们加入用来执行循环的变量loop。最后我们加入用来绕屏幕移动文字和旋转3D物体的cnt1和cnt2。

```c
GLuint base;  // 绘制字体的显示列表的开始位置
GLuint texture[2]; // 保存字体纹理
GLuint loop;  // 通用循环变量

GLfloat cnt1;  // 字体移动计数器1
GLfloat cnt2;  // 字体移动计数器2
```

接下来是读取纹理代码。这跟前面纹理影射教程中的一模一样。 
下面的代码同样对之前教程的代码改动很小。如果你不清楚下面每行的用途，回头复习一下。
注意TextureImage[ ]将保存2个rgb图像记录。复查处理读取或存储纹理的纹理很重要。一个错误的数字可能导致内存溢出或崩溃！ 

```c
int LoadGLTextures()    // 载入位图(调用上面的代码)并转换成纹理
{
    int Status=FALSE;    // 状态指示器
    AUX_RGBImageRec *TextureImage[2];   // 创建纹理的存储空间
```

下一行十分重要。如果你用别的数字替换2将发生严重问题。再查一次！这个数字应该与你在设置TextureImages[ ]时的数字相匹配。
我们将读取的纹理是font.bmp 和bumps.bmp。第二个纹理可用任何你想用的纹理替换。我不是特别有创造性，所以我使的纹理可能有些单调。

```c
    memset(TextureImage,0,sizeof(void *)*2);   // 将指针设为 NULL

    if ((TextureImage[0]=LoadBMP("Data/Font.bmp")) &&  // 载入字体图像
        (TextureImage[1]=LoadBMP("Data/Bumps.bmp")))  // 载入纹理图像
    {
        Status=TRUE;   // 将 Status 设为 TRUE
```

另一十分重要，要检查两遍的行。我无法开始告诉你我收到多少email问“为什么我只看到一个纹理，或为什么我的纹理是全白的！？！”通常问题都出在这行。如果你用1替换2，那么将只创建一个纹理，第二个纹理将显示为全白。如果你用3替换2，你的程序可能崩溃！
你应该只调用glGenTextures()一次。调用glGenTextures()后你应该创建你的所有纹理。我曾见过有人在每创建一个纹理前都加上一行glGenTextures()。这通常导致新建的纹理覆盖了你之前创建的。决定你需要创建多少个纹理是个好主意，调用glGenTextures()一次，然后创建所有的纹理。把glGenTextures()放进循环是不明智的，除非你有自己的理由。

```c
        glGenTextures(2, &texture[0]);    // 创建纹理

        for (loop=0; loop<2; loop++)   // 循环设置所有的纹理
        {
            // 生成所有纹理
            glBindTexture(GL_TEXTURE_2D, texture[loop]);
            glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
            glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[loop]->sizeX, TextureImage[loop]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[loop]->data);
        }
    }
```

下面的几行代码检查我们读取的位图数据是否在内存里。如果是，释放内存。注意我们还要检查并释放rgb图像记录。如果我们使用了3个不同的图像来创建纹理，我们要检查并释放3个rgb图像记录。 

```c
    for (loop=0; loop<2; loop++)
    {
        if (TextureImage[loop])   // 纹理是否存在
        {
            if (TextureImage[loop]->data)  // 纹理图像是否存在
            {
                free(TextureImage[loop]->data); // 释放纹理图像占用的内存
            }
            free(TextureImage[loop]);  // 释放图像结构
        }
    }
    return Status;    // 返回 Status
}
```

现在我们将创建字体。我将以同样的细节来解释这段代码。这并没那么复杂，但是有些数学要了解，我知道不是每个人都喜欢数学。 

```c
GLvoid BuildFont(GLvoid)    // 创建我们的字符显示列表
{
```

下面两个变量将用来保存字体纹理中每个字的位置。cx将用来保存纹理中水平方向的位置，cy将用来保存纹理中竖直方向的位置。

```c
    float cx;     // 字符的X坐标
    float cy;    // 字符的Y坐标
```

接着我们告诉OpenGL我们要建立256个显示列表。变量base将指向第一个显示列表的位置。第二个显示列表将是base+1，第三个是base+2，以此类推。
下面的第二行代码选择我们的字体纹理（texture[0]）。

接着我们告诉OpenGL我们要建立256个显示列表。变量base将指向第一个显示列表的位置。第二个显示列表将是base+1，第三个是base+2，以此类推。
下面的第二行代码选择我们的字体纹理（texture[0]）。

  

```c
    base=glGenLists(256);    // 创建256个显示列表
    glBindTexture(GL_TEXTURE_2D, texture[0]);   // 选择字符图象
```

现在我们开始循环。循环间创建所有的256个字符，每个存在它自己的显示列表里。  

```c
    for (loop=0; loop<256; loop++)   // 循环256个显示列表
    {
```

下面的第一行或许看上去让人有点困惑。%符号表示loop除以16的余数。cx将我们通过字体纹理从左至右移动。你将注意到在后面的代码中我们用1减去cy从而从上到下而不是从下到上移动我们。%符号很难解释，但我将尝试去解释。

我们真正关心的是（loop%16）。/16只是将结果转化为纹理坐标。所以如果loop等于16，cx将等于16/16的余数也就是0。但cy将等于16/16也就是1。所以我们将下移一个字符的高度，且我们将不往右移。如果loop等于17，cx将等于17/16也就是1.0625。余数0.625也等于1/16。意味着我们将右移一个字符。cy将仍是1因为我们只关心小数点左边的数字。18/16将右移2个字符，但仍下移一个字符。如果loop是32，cx将再次等于0，因为32除以16没有余数，但cy将等于2。因为小数点左边的数字现在是2，将下移2个字符。这么讲清楚吗？

```c
        cx=float(loop%16)/16.0f;   // 当前字符的X坐标
        cy=float(loop/16)/16.0f;   // 当前字符的Y坐标
```

Ok。现在我们通过从字体纹理中依据cx和cy的值选择一个单独的字符创建了2D字体。在下面的行里我们给base的值加上loop，若不这么做，每个字都将建在第一个显示列表里。我们当然不想要那样的事发生，所以通过给base加上loop，我们创建的每个字都被存在下个可用的显示列表里。 

```c
        glNewList(base+loop,GL_COMPILE);  //开始创建显示列表
```

现在我们已选择了我们要创建的显示列表，我们创建字符。这是通过绘制四边形，然后给他贴上字体纹理中的单个字符的纹理来完成的。 

```c
        glBegin(GL_QUADS);   // 使用四边形显示每一个字符
```

cx和cy应该保存一个从0.0到1.0的非常小的浮点数。如果cx和cy同时为0，下面第一行的代码将为：glTexCoord2f(0.0f,1-0.0f-0.0625f)。记得0.0625正是我们纹理的1/16，或者说是一个字符的宽/高。下面的纹理坐标将是我们纹理的左下角。
注意我们使用glVertex2i(x,y)而不是glVertex3f(x,y,z)。我们的字体是2D字体，所以我们不需要z值。因为我们使用的是正交投影，我们不需要移进屏幕。在一个正交投影平面绘图你所需的是指定x和y坐标。因为我们的屏幕是以像素形式从0到639（宽）从0到479（高），我们既不需用浮点数也不用负数:)

我们设置正交投影屏幕的方式是，(0,0)将是屏幕的左下角，(640,480)是屏幕的右上角。x轴上0是屏幕的左边界，639是右边界。y轴上0时下便捷，479是上便捷。基本上我们避免了负坐标。对那些不在乎透视，更愿意同像素而不是单元打交道的人来说更方便:)

```c
        glTexCoord2f(cx,1-cy-0.0625f); // 左下角的纹理坐标
        glVertex2i(0,0);  // 左下角的坐标
```

下一个纹理坐标现在是上个纹理坐标右边1/16（刚好一个字符宽）。所以这将是纹理的右下角。

```c
        glTexCoord2f(cx+0.0625f,1-cy-0.0625f); // 右下角的纹理坐标
        glVertex2i(16,0);  // 右下角的坐标
```

第三个纹理坐标在我们的字符的最右边，但上移了纹理的1/16（刚好一个字符高）。这将是一个单独字符的右上角。 

```c
        glTexCoord2f(cx+0.0625f,1-cy); // 右上角的纹理坐标
        glVertex2i(16,16);  // 右上角的坐标
```

最后我们左移来设置字符左上角的最后一个纹理坐标。  

```c
        glTexCoord2f(cx,1-cy);  // 左上角的纹理坐标
        glVertex2i(0,16);  // 左上角的坐标
        glEnd();   // 四边形字符绘制完成
```

最终，我们右移了10个像素，置于纹理的右边。如果我们不平移，文字将被绘制到各自的上面。由于我们的字体太窄，我们不想右移16个像素。如果那样的话，每个字之间将有很大间隔。只移动10个像素去除了间隔。

```c
        glTranslated(10,0,0);   // 绘制完一个字符，向右平移16个单位
        glEndList();    // 字符显示列表结束
	}     // 循环建立256个显示列表
}
```

下面这段代码与我们在其它字体教程中用来在程序退出前释放显示列表的相同。所有自base开始的256个显示列表都将被销毁（这样做很好！）。

```c
GLvoid KillFont(GLvoid)    
{
    glDeleteLists(base,256);   // 从内存中删除256个显示列表
}
```

下一段代码将完成绘图。一切都几乎是新的，所以我将尽可能详细的解释每一行。一个小提示：很多都可加入这段代码，像是变量的支持，字体大小、间距的调整，和很多为恢复到我们决定打印前的状况所做的检查。
glPrint()有三个参数。第一个是屏幕上x轴上的位置（从左至右的位置），下一个是y轴上的位置（从下到上...0是底部，越往上越大）。然后是字符串（我们想打印的文字），最后是一个叫做set的变量。如果你看过Giuseppe D'Agata制作的位图，你会注意到有两个不同的字符集。第一个字符集是普通的，第二个是斜体的。如果set为0，第一个字符集被选中。若set为1则选择第二个字符集。

```c
GLvoid glPrint(GLint x, GLint y, char *string, int set)  // 绘制字符
{
```

我们要做的第一件事是确保set的值非0即1。如果set大于1，我们将使它等于1。    

```c
    if (set>1)    // 如果字符集大于1
    {
        set=1;    // 设置其为1
    }
```

现在我们选择字体纹理。我们这么做是防止在我们决定往屏幕上输出东西时选择了不同的纹理。  

```c
    glBindTexture(GL_TEXTURE_2D, texture[0]);  // 绑定为字体纹理
```

现在我们禁用深度测试。我这么做是因为混合的效果会更好。如果你不禁用深度测试，文字可能会被什么东西挡住，或得不到正确的混合效果。如果你不打算混合文字（那样文字周围的黑色区域就不会显示）你可以启用深度测试。

```c
    glDisable(GL_DEPTH_TEST);   // 禁止深度测试
```

下面几行十分重要！我们选择投影矩阵。之后使用一个叫做glPushMatrix()的命令。glPushMatrix存储当前矩阵（投影）。有些像计算器的存储按钮。 

```c
    glMatrixMode(GL_PROJECTION);   // 选择投影矩阵
    glPushMatrix();    // 保存当前的投影矩阵
```

现在我们保存了投影矩阵，重置矩阵并设置正交投影屏幕。第一和第三个数字（0）表示屏幕的底边和左边。如果愿意我们可以将屏幕的左边设为-640，但如果不需要我们为什么要设负数呢。第二和第四个数字表示屏幕的上边和右边。将这些值设为你当前使用的分辨率是明智的做法。我们不需要用到深度，所以我们将z值设为-1与1。 

```c
    glLoadIdentity();    // 重置投影矩阵
    glOrtho(0,640,0,480,-1,1);    // 设置正投影的可视区域
```

现在我们选择模型视点矩阵，用glPushMatrix()保存当前设置。然后我们重置模型视点矩阵以便在正交投影视点下工作。

```c
    glMatrixMode(GL_MODELVIEW);    // 选择模型变换矩阵
    glPushMatrix();    // 保存当前的模型变换矩阵
    glLoadIdentity();    // 重置模型变换矩阵
```

在保存了透视参数，设置了正交投影屏幕后，现在我们可以绘制文字了。我们从移动到绘制文字的位置开始。我们使用 glTranslated()而不是glTranslatef()因为我们处理的是像素，所以浮点值并不重要。毕竟，你不可能用半个像素:) 

```c
    glTranslated(x,y,0);    // 把字符原点移动到(x,y)位置
```

下面这行选择我们要使用的字符集。如果我们想使用第二个字符集，我们在当前的显示列表基数上加上128（128时我们256个字符的一半）。通过加上128，我们跳过了头128个字符。 

```c
    glListBase(base-32+(128*set));   // 选择字符集
```

现在剩下的就是在屏幕上绘制文字了。我们同其它字体教程一样来完成这步。我们使用glCallLists()。strlen(string)是字符串的长度（我们想绘制多少字符），GL_UNSIGNED_BYTE意味着每个字符被表示为一个无符号字节（一个字节是一个从0到255的值）。最后，字符串保存我们想打印的文字。

```c
    glCallLists(strlen(string),GL_BYTE,string);   // 把字符串写入到屏幕
```

现在我们所要做的是恢复透视视图。我们选择投影矩阵并用glPopMatrix()恢复我们先前用glPushMatrix()保存的设置。用相反的顺序恢复设置很重要。

```c
    glMatrixMode(GL_PROJECTION);   // 选择投影矩阵
    glPopMatrix();    // 设置为保存的矩阵
```

现在我们选择模型视点矩阵，做相同的工作。我们使用glPopMatrix()恢复模型视点矩阵到我们设置正交投影显示之前。

```c
    glMatrixMode(GL_MODELVIEW);    // 选择模型矩阵
    glPopMatrix();    // 设置为保存的矩阵
```

最后，我们启用深度测试。如果你没有在上面的代码中关闭深度测试，你不需要这行。  

```c
	glEnable(GL_DEPTH_TEST);   // 启用深度测试
}
```

我们没有修改ReSizeGLScene()，所以我们直接跳到InitGL()。

```c
int InitGL(GLvoid)    // 此处开始对OpenGL进行所有设置
{
```

我们跳到创建纹理的代码。如果由于某种原因创建纹理失败了，我们返回FALSE。这将让我们的程序知道发生了一个错误从而关闭程序。 

```c
    if (!LoadGLTextures())    // 调用纹理载入子例程
    {
        return FALSE;    // 如果未能载入，返回FALSE
    }
```

如果没有错，我们跳到创建字体的代码。在创建字体时不会出什么错所以我们省略了错误检查。

```c
    BuildFont();    // 创建字符显示列表
```

现在我们做通常的GL设置。我们将背景色设为黑色，将深度清为1.0。我们选择一个深度测试模式和一个混合模式。我们启用平滑着色，最后启用2维纹理映射。 

```c
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);   // 黑色背景
    glClearDepth(1.0);    // 设置深度缓存
    glDepthFunc(GL_LEQUAL);    // 所作深度测试的类型
    glBlendFunc(GL_SRC_ALPHA,GL_ONE);   // 设置混合因子
    glShadeModel(GL_SMOOTH);    // 启用阴影平滑
    glEnable(GL_TEXTURE_2D);    // 启用纹理映射
    return TRUE;    // 初始化成功
}
```

下面这段代码将完成绘图。我们先绘制3D物体最后绘制文字，这样文字将显示在3D物体上面，而不会被3D物体遮住。我之所以加入一个3D物体是为了演示透视投影和正交投影可同时使用。 

```c
int DrawGLScene(GLvoid)    // 从这里开始进行所有的绘制
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // 清除屏幕和深度缓存
    glLoadIdentity();    // 重置当前的模型观察矩阵
```


我们选择bumps.bmp纹理来创建简单的小3D物体。为了看见3D物体，我们往屏幕内移动5个单位。我们绕z轴旋转45度。这将使我们的四边形顺时针旋转45度，让我们的四边形看起来更像钻石而不是矩形。 

```c
    glBindTexture(GL_TEXTURE_2D, texture[1]);   // 设置为图像纹理
    glTranslatef(0.0f,0.0f,-5.0f);   // 移入屏幕5个单位
    glRotatef(45.0f,0.0f,0.0f,1.0f);   // 沿Z轴旋转45度
```

在旋转45度后，我们让物体同时绕x轴和y轴旋转cnt1x30度。这使我们的物体象在一个点上旋转的钻石那样旋转。 

```c
    glRotatef(cnt1*30.0f,1.0f,1.0f,0.0f);   // 沿(1,1,0)轴旋转30度
```

我们关闭混合（我们希望3D物体看上去像实心的），设置颜色为亮白色。然后我们绘制一个单独的用了纹理映像的四边形。 

```c
    glDisable(GL_BLEND);    // 关闭混合
    glColor3f(1.0f,1.0f,1.0f);    //设置颜色为白色
    glBegin(GL_QUADS);    // 绘制纹理四边形
    glTexCoord2d(0.0f,0.0f);   
    glVertex2f(-1.0f, 1.0f);   
    glTexCoord2d(1.0f,0.0f);   
    glVertex2f( 1.0f, 1.0f);   
    glTexCoord2d(1.0f,1.0f);   
    glVertex2f( 1.0f,-1.0f);   
    glTexCoord2d(0.0f,1.0f);   
    glVertex2f(-1.0f,-1.0f);   
    glEnd(); 
```

在画完第一个四边形后，我们立即同时绕x轴和y轴旋转90度。然后我们画下一个四边形，。第二个四边形从第一个四边形的中间切过去，来形成一个好看的形状。 

在画完第一个四边形后，我们立即同时绕x轴和y轴旋转90度。然后我们画下一个四边形，。第二个四边形从第一个四边形的中间切过去，来形成一个好看的形状。 

```c
    glRotatef(90.0f,1.0f,1.0f,0.0f);   // 沿(1,1,0)轴旋转90度
    glBegin(GL_QUADS);    // 绘制第二个四边形，与第一个四边形垂直
    glTexCoord2d(0.0f,0.0f);   
    glVertex2f(-1.0f, 1.0f);   
    glTexCoord2d(1.0f,0.0f);   
    glVertex2f( 1.0f, 1.0f);   
    glTexCoord2d(1.0f,1.0f);   
    glVertex2f( 1.0f,-1.0f);   
    glTexCoord2d(0.0f,1.0f);   
    glVertex2f(-1.0f,-1.0f);   
    glEnd();   
```

 在绘制完有纹理贴图的四边形后，我们开启混合并绘制文字。

在绘制完有纹理贴图的四边形后，我们开启混合并绘制文字。  

```c
    glEnable(GL_BLEND);    // 启用混合操作
    glLoadIdentity();    // 重置视口
```

我们使用同其它字体教程一样的生成很棒的颜色的代码。颜色会随着文字的移动而逐渐改变。

```c
    // 根据字体位置设置颜色
    glColor3f(1.0f*float(cos(cnt1)),1.0f*float(sin(cnt2)),1.0f-0.5f*float(cos(cnt1+cnt2)));
```

我们来绘制文字。我们仍然使用glPrint()。第一个参数是x坐标，第二个是y坐标，第三个（"NeHe"）是要绘制的文字，最后一个是使用的字符集（0-普通，1-斜体）。
正如你猜的，我们使用SIN和COS连同计数器cnt1和cnt2来移动文字。如果你不清楚SIN和COS的作用，阅读之前的教程。

```c
    glPrint(int((280+250*cos(cnt1))),int(235+200*sin(cnt2)),"NeHe",0); 

    glColor3f(1.0f*float(sin(cnt2)),1.0f-0.5f*float(cos(cnt1+cnt2)),1.0f*float(cos(cnt1)));
    glPrint(int((280+230*cos(cnt2))),int(235+200*sin(cnt1)),"OpenGL",1); 
```


我们将屏幕底部作者名字的颜色设为深蓝色和白色。然后用亮白色文字再次绘制他的名字。亮白色文字是有点偏蓝色的文字。这创造出一种附有阴影的样子。（如果混合没打开则没有这种效果）。  

``` c
    glColor3f(0.0f,0.0f,1.0f);   
    glPrint(int(240+200*cos((cnt2+cnt1)/5)),2,"Giuseppe D'Agata",0); 

    glColor3f(1.0f,1.0f,1.0f);   
    glPrint(int(242+200*cos((cnt2+cnt1)/5)),2,"Giuseppe D'Agata",0); 
```

我们所做的最后一件事是以不同的速率递增我们的计数器。这使得文字移动，3D物体自转。  

``` c
    cnt1+=0.01f;    // 增加计数器值
    cnt2+=0.0081f;    // 增加计数器值
    return TRUE;    // 成功返回
}
```

KillGLWindow(), CreateGLWindow()和WndProc()的代码都没有更改，所以我们跳过它们。 


如下所示，最后要做的是在KillGLWindow()的最后添加KillFont()。添加这行很重要，它在我们退出程序前将所有的清除干净。  

```c
KillFont();   // 删除字体
```

我认为现在我可以正式说我的网站已经把所有绘制文字的方法教给大家了{笑}。总之，我认为我的教程很不错。这课的代码可在任何能运行OpenGL的电脑上运行，它很容易使用，且这样绘制文字对系统的资源消耗很少。
我要感谢这篇教程的原作者Giuseppe D'Agata。我做了大量的修改，并将它转变为新式的代码，但要是没有他寄给我这份代码我是不会完成这篇教程的。他的代码有更多的选项，像是改变文字间距等等。但我用很cool的3D物体来弥补了{笑}。

我希望你们喜欢这篇教程。若有什么问题，给我或Giuseppe D'Agata发email。

Giuseppe D'Agata

Jeff Molofee (NeHe)

# 第十八课 二次几何体

利用二次几何体，你可以很容易的创建球，圆盘，圆柱和圆锥。

二次曲面是一种画复合对象的方法，这种方法通常并不需要很多的三角形。我们将要使用第七课的代码。我们将要增加7个变量以及修改纹理以增加一些变化 ： 

```c
bool  sp;   // 空格键是否按下

int part1;   // 圆盘的起始角度
int part2;   // 圆盘的结束角度
int p1=0;   // 增量1
int p2=1;   // 增量1
GLUquadricObj *quadratic;   // 二次几何体
GLuint object=0;   // 二次几何体标示符
```

好了我们现在开始搞InitGL()函数。我们打算增加3行代码用来初始化我们的二次曲面。这3行代码将在你使1号光源有效后增加，但是要在返回之前。第一行代码将初始化二次曲面并且创建一个指向改二次曲面的指针，如果改二次曲面不能被创建的话，那么该指针就是NULL。第二行代码将在二次曲面的表面创建平滑的法向量，这样当灯光照上去的时候将会好看些。另外一些可能的取值是：GLU_NONE和GLU_FLAT。最后我们使在二次曲面表面的纹理映射有效。 

```c
quadratic=gluNewQuadric();  // 创建二次几何体
gluQuadricNormals(quadratic, GLU_SMOOTH); // 使用平滑法线
gluQuadricTexture(quadratic, GL_TRUE); // 使用纹理
```

现在我决定在本课里保留立方体，这样你可以看到纹理是如何映射到二次曲面对象上的。而且我打算将绘制立方体的代码定义为一个单独的函数，这样我们在定义函数Draw()的时候它将会变的不那么凌乱。每个人都应该记住这些代码： 

现在我决定在本课里保留立方体，这样你可以看到纹理是如何映射到二次曲面对象上的。而且我打算将绘制立方体的代码定义为一个单独的函数，这样我们在定义函数Draw()的时候它将会变的不那么凌乱。每个人都应该记住这些代码： 

```c
GLvoid glDrawCube()   // 绘制立方体
{
    glBegin(GL_QUADS);  
    // 前面
    glNormal3f( 0.0f, 0.0f, 1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    // 后面
    glNormal3f( 0.0f, 0.0f,-1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    // 上面
    glNormal3f( 0.0f, 1.0f, 0.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    // 下面
    glNormal3f( 0.0f,-1.0f, 0.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    // 右面
    glNormal3f( 1.0f, 0.0f, 0.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.0f, 1.0f, -1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f( 1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f( 1.0f, -1.0f, 1.0f); 
    // 左面
    glNormal3f(-1.0f, 0.0f, 0.0f); 
    glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.0f, -1.0f, -1.0f); 
    glTexCoord2f(1.0f, 0.0f); glVertex3f(-1.0f, -1.0f, 1.0f); 
    glTexCoord2f(1.0f, 1.0f); glVertex3f(-1.0f, 1.0f, 1.0f); 
    glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.0f, 1.0f, -1.0f); 
    glEnd();   
}
```

接下来就是场景绘制函数了，在这里我只写一个简单的例子。并且当我绘制一个部分的盘子的时候，我将使用一个静态变量（一个局部的变量，该变量可以保留他的值不论你任何时候调用他）来表达一个非常酷的效果。为了清晰起见我将要重写DrawGLScene函数。
你们将会注意到当我讨论这些正在使用的参数时我忽略了当前函数的第一个参数（quadratic）。这个参数将被除立方体外的所有对象使用。所以当我讨论这些参数的时候我忽略了它。 

```c
int DrawGLScene(GLvoid)   
{
    //...
    // 这部分是新增加的
    switch(object)   // 绘制哪一种二次几何体
    {
        case 0:    // 绘制立方体
            glDrawCube();   
            break;   
```

我们创建的第2个对象是一个圆柱体。参数1（1.0F）是圆柱体的底面半径，参数2（1.0F）是圆柱体的饿顶面半径，参数3（3.0F）是圆柱体的高度。参数4（32）是纬线（环绕Z轴有多少细分），参数5（32）是经线（沿着Z轴有多少细分）。细分越多该对象就越细致。我们可以用增加细分的方法来增加对象的多边形数。因此你可以牺牲速度换回质量（以时间换质量），大多数的时候我们都可以很容易的找到一个合适的“度”。

```c
        case 1:    // 绘制圆柱体
        glTranslatef(0.0f,0.0f,-1.5f);  
        gluCylinder(quadratic,1.0f,1.0f,3.0f,32,32); 
        break;
```


对象3将会创建一个CD样子的盘子。参数1（0.5F）是盘子的内圆半径，该参数可以为0，则表示在盘子中间没孔，内圆半径越大孔越大。参数2（1.5F）表示外圆半径，这个参数必须比内圆半径大。参数3（32）是组成该盘子的切片的数量，这个数量可以想象成披萨饼中的切片的数量。切片越多，外圆边缘就越平滑。最后一个参数（32）是组成盘子的环的数量。环很像唱片上的轨迹，一环套一环。这些环从内圆半径细分到外圆半径。再说一次，细分越多，速度越慢。 

```c
        case 2:    // 绘制圆盘
        gluDisk(quadratic,0.5f,1.5f,32,32); 
        break;   
```


我们的第4个对象我知道你们为描述它耗尽精力。就是球。绘制球将会变的非常简单。参数1是球的半径。如果你无法理解半径/直径等等的话，可以理解成物体中心到物体外部的距离，在这里我们使用1.3F作为半径。接下来两个参数就是细分了，和圆柱体一样，参数2是纬线，参数3是经线。细分越多球看起来就越平滑，通常球需要多一些的细分以使他们看起来平滑。

  

```c
        case 3:    // 绘制球
        gluSphere(quadratic,1.3f,32,32); 
        break; 
```

我们创建的第4个对象使用与我们曾经创建的圆柱体一样的命令来创建，如果你还记得的话，我们可以通过控制参数2和参数3来控制顶面半径和地面半径。因此我们可以使顶面半径为0来绘制一个圆锥体，顶面半径为0将会在顶面上创建一个点。因此在下面的代码中，我们使顶面半径等于0，这将会创建一个点，同时也就创建了我们的圆锥。 

我们创建的第4个对象使用与我们曾经创建的圆柱体一样的命令来创建，如果你还记得的话，我们可以通过控制参数2和参数3来控制顶面半径和地面半径。因此我们可以使顶面半径为0来绘制一个圆锥体，顶面半径为0将会在顶面上创建一个点。因此在下面的代码中，我们使顶面半径等于0，这将会创建一个点，同时也就创建了我们的圆锥。 

```c
        case 4:    // 绘制圆锥
        glTranslatef(0.0f,0.0f,-1.5f);  
        gluCylinder(quadratic,1.0f,0.0f,3.0f,32,32); 
        break;   
```

我们的第6个对象将被gluPartialDisk函数创建。我们打算创建的这个对象使用了一些命令，这些命令在我们创建对象之前，你将会清楚的看到。但是命令gluPartialDisk拥有两个新的参数。第5个参数是我们想要绘制的部分盘子的开始角度，参数6是旋转角，也就是转过的角度。我们将要增加旋转角，这将引起盘子沿顺时针方向缓慢的被绘制在屏幕上。一旦旋转角达到360度我们将开始增加开始角度，这样盘子看起来就想是被逐渐的抹去一样。我们将重复这些过程。 

```c
        case 5:    // 绘制部分圆盘
        part1+=p1;   
        part2+=p2;   

        if(part1>359)   
        {
            p1=0;   
            part1=0;  
            p2=1;   
            part2=0;  
        }
        if(part2>359)   
        {
            p1=1;   
            p2=0;   
        }
        gluPartialDisk(quadratic,0.5f,1.5f,32,32,part1,part2-part1); 
        break;   
	};

	//...
}
```

In the KillGLWindow() section of code, we need to delete the quadratic to free up system resources. We do this with the command gluDeleteQuadratic.  

```c
GLvoid KillGLWindow(GLvoid)   
{
    gluDeleteQuadric(quadratic);  // 删除二次几何体
```

在最后，我给出键盘输入代码。仅仅增加一些对剩余键的检查。

```c
    if (keys[' '] && !sp) // 空格是否按下
    {
        sp=TRUE;  // 是,则绘制下一种二次几何体
        object++; 
        if(object>5) 
            object=0; 
    }
    if (!keys[' '])  // 空格是否释放
    {
        sp=FALSE;  // 记录这个状态
    }
```


这就是全部了。现在你可以在OpenGL中绘制二次曲面了。

# 第十九课 粒子系统

你是否希望创建爆炸，喷泉，流星之类的效果。这一课将告诉你如何创建一个简单的例子系统，并用它来创建一种喷射的效果。

欢迎来到第十九课.你已经学习了很多知识,并且现在想自己来实践.我将在这讲解一个新命令... 三角形带(我的理解就是画很多三角形来组合成我们要的形状),它非常容易使用,当画很多三角形的时候能加快你程序的运行速度.在本课中,我将会教你该如何做一个半复杂的微粒程序.一旦您了解微粒程序的原理后,在创建例如:火,烟,喷泉等效果将是很轻松的事情.我必须警告你!直到今天我从未写一个真正的粒子程序.我想写一个"出名"的复杂的粒子程序.我尝试过,但在我了解我不能控制所有点变疯狂之后我放弃了!!!你也许不相信我要告诉你的,但这个课程从头到尾都是我自己的想法.开始我没有一点想法,并且没有任何技术数据放在我的面前.我开始考虑粒子,突然我的脑袋装满想法(脑袋开启了??):给予每个粒子生命,任意变化颜色,速度,重力影响等等.来适应环境的变化,把每个粒子看成单一的从这个点运动到另一个点的颗粒.很快我完成了这个项目.我看看时钟然后有个想法突然出现.四个小时过去了!我偶尔记得已经停止喝咖啡,眨眼,但是4个小时...?尽管这个程序我觉得很棒,并象我想象的那么严密的运行,但它不可能是最好的粒子引擎,这个我不关心,只要他运行好就可以.并且我能把它运行在我的项目中.如果你是那种想了解透彻的人,那么你要花费很多时间在网络上查找资料并弄明白它.在程序中有很多小的代码会看起来很模糊:)本课教程所用的部分代码来自于Lesson1.但有很多新的代码,因此我将重写一些发生代码变化的部分(使它更容易了解).
下面用到的代码来自于Lesson6,我将会增加5行新的代码在我们程序的前面.第一行"stdio.h"允许我们读文件中的数据.它和我们以前用在纹理映射当中是一样的.第二行定义了一些我们要在屏幕上显示的粒子的数目.告诉程序MAX_PARTICLES在这里的数值为1000.第三条行将不断分离的彩色的粒子栓牢在一起,并设置为默认情况.sp和rp用来确定空格键和返回键是否有按住.

```c
#define MAX_PARTICLES 1000 // 定义最大的粒子数
bool rainbow=true;  // 是否为彩虹模式
bool sp;  // 空格键是否被按下
bool rp;  // 回车键是否被按下
```

下面四行是复杂的变量.变量slowdown控制粒子移动的快慢.数值愈高,移动越慢.数值越底,移动越快.如果数值降低,粒子将快速的移动!粒子的速度影响它们在荧屏中移动的距离.记住速度慢的粒子不会射很远的.变量xspeed和yspeed控制尾部的方向.xspeed将会增加粒子在x轴上速度.如果xspeed是正值粒子将会向右边移动多.如果xspeed负价值,粒子将会向左边移动多.那个值越高,就向那个方向移动比较多.yspeed工作相同的方法,但是在y轴上.因为有其它的因素影响粒子的运动,所以我要说"多".xspeed和yspeed有助于在我们想要的方向上移动粒子.最后是变量zoom,我们用该变量移入或移出我们的屏幕.在粒子引擎里,有时可看见更多的图象,而且当接近你时很酷

```c
float slowdown=2.0f;  // 减速粒子
float xspeed;  // X方向的速度
float yspeed;  // Y方向的速度
float zoom=-40.0f;  // 沿Z轴缩放
```

我们定义了一个复杂的循环变量叫做Loop.我们用这变量预先定义粒子并在屏幕中画粒子.col用来给予粒子不同的颜色.delay用来控制在彩虹模式中圆的颜色变化.最后,我们设定一个存储空间(粒子纹理).我用纹理而不用点的重要原因是,点的速度慢,而且挺麻烦的.其次纹理很酷:)你用一个正方形的粒子,一张你脸的小图片,一张星星的图片等等.很好控制! 

```c
GLuint loop;  // 循环变量
GLuint col;  // 当前的颜色
GLuint delay;  // 彩虹效果延迟
```

好!现在是有趣的东西.下段程序描述单一粒子结构,这是我们给予粒子的属性.我们用布尔型变量active开始,如果为true,我们的粒子为活跃的.如果为false则粒子为死的,此时我们就删除它.在程序中我没有使用活跃的,因为它很好的实现.变量life和fade来控制粒子显示多久以及显示时候的亮度.随着life数值的降低fade的数值也相应降低.这将导致一些粒子比其他粒子燃烧的时间长.

```c
typedef struct   // 创建粒子数据结构
{
    bool active;   // 是否激活
    float life;   // 粒子生命
    float fade;   // 衰减速度
```

变量r,g和b用来表示粒子的红色强度,绿色强度和蓝色强度.当r的值变成1.0f时粒子将会很红,当三个变量全为1.0f时则粒子将变成白色.

```c
    float r;   // 红色值
    float g;   // 绿色值
    float b;   // 蓝色值
```

变量x.y和z控制粒子在屏幕上显示的位置.x表示粒子在x轴上的位置.y表示y轴上的位置.z表示粒子z轴上的位置

```c
    float x;   // X 位置
    float y;   // Y 位置
    float z;   // Z 位置
```

下面三个变量很重要.这三个变量控制粒子在每个轴上移动的快慢和方向.如果xi是负价粒子将会向左移动,正值将会向右移动.如果yi是负值粒子将会向下移动,正值将向上.最后,如果zi负值粒子将会向荧屏内部移动,正植将移向观察者. 

```c
    float xi;   // X 方向
    float yi;   // Y 方向
    float zi;   // Z 方向
```

最后,另外3个变量!每一个变量可被看成加速度.如果xg正值时,粒子将会被拉倒右边,负值将拉向左边.所以如果粒子向左移动(负的)而我们给它一个正的加速度,粒子速度将变慢.最后将向反方向移动(高中物理).yg拉下或拉上.zg拉进或拉出屏幕.

```c
    float xg;   // X 方向重力加速度
    float yg;   // Y 方向重力加速度
    float zg;   // Z 方向重力加速度
```

结构的名字为particles. 

```c
}
particles;   // 粒子数据结构
```

下面我们创建一个数组叫particle.数组存储MAX_PARTICLES个元素.也就是说我们创建1000(MAX_PARTICLES)个粒子,存储空间为每个粒子提供相应的信息

```c
particles particle[MAX_PARTICLES];  // 保存1000个粒子的数组
```

在颜色数组上我们减少一些代码来存储12中不同的颜色.对每一个颜色从0到11我们存储亮红,亮绿,和亮蓝.下面的颜色表里包含12个渐变颜色从红色到紫罗兰色 

```c
static GLfloat colors[12][3]=  // 彩虹颜色
{
    {1.0f,0.5f,0.5f},{1.0f,0.75f,0.5f},{1.0f,1.0f,0.5f},{0.75f,1.0f,0.5f},
    {0.5f,1.0f,0.5f},{0.5f,1.0f,0.75f},{0.5f,1.0f,1.0f},{0.5f,0.75f,1.0f},
    {0.5f,0.5f,1.0f},{0.75f,0.5f,1.0f},{1.0f,0.5f,1.0f},{1.0f,0.5f,0.75f}
};
```

这段代码调用前面的代码载入位图，与前面的代码相同，只是位图的名称不同。载入一符名为Particle.bmp的位图 

```c
if (TextureImage[0]=LoadBMP("Data/Particle.bmp")) // 载入粒子纹理
```

窗口改变大小的代码和前面一样，不需要改变  


我们使用光滑的阴影,清除背景为黑色,关闭深度测试,绑定并映射纹理.启用映射位图后我们选择粒子纹理。唯一的改变就是禁用深度测试和初始化粒子

```c
glDisable(GL_DEPTH_TEST);   //禁止深度测试
```

下面代码初始化每个粒子.我们从活跃的粒子开始.如果粒子不活跃,它在荧屏上将不出现,无论它有多少life.当我们使粒子活跃之後,我们给它life.我怀疑给粒子生命和颜色渐变的是否是最好的方法,但当它运行一次后,效果很好!life满值是1.0f.这也给粒子完整的光亮.

```c
for (loop=0;loop<MAX_PARTICLES;loop++)  //初始化所有的粒子
{
    particle[loop].active=true;   // 使所有的粒子为激活状态
    particle[loop].life=1.0f;   // 所有的粒子生命值为最大
```

我们通过给定的值来设定粒子退色快慢.每次粒子被拉的时候life随着fade而减小.结束的数值将是0~99中的任意一个,然后平分1000份来得到一个很小的浮点数.最后我们把结果加上0.003f来使fade速度值不为0

```c
	particle[loop].fade=float(rand()%100)/1000.0f+0.003f; // 随机生成衰减速率
```

既然粒子是活跃的,而且我们又给它生命,下面将给它颜色数值.一开始,我们就想每个粒子有不同的颜色.我怎么做才能使每个粒子与前面颜色箱里的颜色一一对应那?数学很简单,我们用loop变量乘以箱子中颜色的数目与粒子最大值(MAX_PARTICLES)的余数.这样防止最后的颜色数值大于最大的颜色数值(12).举例:900*(12/900)=12.1000*(12/1000)=12,等等

```c
    particle[loop].r=colors[loop*(12/MAX_PARTICLES)][0]; // 粒子的红色颜色
    particle[loop].g=colors[loop*(12/MAX_PARTICLES)][1]; // 粒子的绿色颜色
    particle[loop].b=colors[loop*(12/MAX_PARTICLES)][2]; // 粒子的蓝色颜色
```

现在设定每个粒子移动的方向和速度.我们通过将结果乘于10.0f来创造开始时的爆炸效果.我们将会以任意一个正或负值结束.这个数值将以任意速度,任意方向移动粒子. 

```c
    particle[loop].xi=float((rand()%50)-26.0f)*10.0f; // 随机生成X轴方向速度
    particle[loop].yi=float((rand()%50)-25.0f)*10.0f; // 随机生成Y轴方向速度
    particle[loop].zi=float((rand()%50)-25.0f)*10.0f; // 随机生成Z轴方向速度
```

最后,我们设定加速度的数值.不像一般的加速度仅仅把事物拉下,我们的加速度能拉出,拉下,拉左,拉右,拉前和拉后粒子.开始我们需要强大的向下加速度.为了达到这样的效果我们将xg设为0.0f.在x方向没有拉力.我们设yg为-0.8f来产生一个向下的拉力.如果值为正则拉向上.我们不希望粒子拉近或远离我们,所以将zg设为0.0f

```c
    particle[loop].xg=0.0f;   // 设置X轴方向加速度为0
    particle[loop].yg=-0.8f;   // 设置Y轴方向加速度为-0.8
    particle[loop].zg=0.0f;   // 设置Z轴方向加速度为0
}
```

现在为有趣的部分.下面的部分是我们从哪里拉粒子,检查加速度等等.你要明白它是怎么实现的,因此仔细的看:)我们重置Modelview巨阵.在画粒子位置的时候用glVertex3f()命令来代替tranlations,这样在我们画粒子的时候不会改变modelview巨阵

```c
int DrawGLScene(GLvoid)    // 绘制粒子
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  // 以黑色背景清楚
    glLoadIdentity();    // 重置模型变换矩阵
```

我们开始创建一个循环loop.这个环将会更新每一个粒子.  

```c
    for (loop=0;loop<MAX_PARTICLES;loop++)   // 循环所有的粒子
    {
```

首先我们做的事物是检查粒子是否活跃.如果不活跃,则不被更新.在这个程序中,它们始终活跃.但是在你自己的程序中,你可能想要使某粒子不活跃

```c
        if (particle[loop].active)   // 如果粒子为激活的
        {
```

下面三个变量是我们确定x,y和z位置的暂时变量.注意:在z的位置上我们加上zoom以便我们的场景在以前的基础上再移入zoom个位置.particle[loop].x告诉我们要画的x的位置.particle[loop].y告诉我们要画的y的位置.particle[loop].z告诉我们要画的z的位置

```c
            float x=particle[loop].x;  // 返回X轴的位置
            float y=particle[loop].y;  // 返回Y轴的位置
            float z=particle[loop].z+zoom;  // 返回Z轴的位置
```

既然知道粒子位置,就能给粒子上色.particle[loop].r保存粒子的亮红,particle[loop].g保存粒子的亮绿,particle[loop].b保存粒子的亮蓝.注意我用alpha为粒子生命.当粒子要燃尽时,它会越来越透明直到它最后消失.这就是为什么粒子的生命不应该超过1.0f.如果你想粒子燃烧时间长,可降低fade减小的速度

```c
            // 设置粒子颜色
            glColor4f(particle[loop].r,particle[loop].g,particle[loop].b,particle[loop].life);
```

我们有粒子的位置,并设置颜色了.所以现在我们来画我们的粒子.我们用一个三角形带来代替一个四边形这样使程序运行快一点.很多3D card画三角形带比画四边形要快的多.有些3D card将四边形分成两个三角形,而有些不.所以我们按照我们自己的想法来,所以我们来画一个生动的三角形带

```c
            glBegin(GL_TRIANGLE_STRIP);  // 绘制三角形带
```

从红宝书引述:三角形带就是画一连续的三角形(三个边的多角形)使用vertices V0,V1,V2,然后V2,V1,V3(注意顺序),然后V2,V3,V4等等.画三角形的顺序一样才能保证三角形带为相同的表面.要求方向是很重要的,例如:剔除,最少用三点来画当第一个三角形使用vertices0,1和2被画.如果你看图片你将会理解用顶点0,1和2构造第一个三角形(顶端右边,顶端左边,底部的右边).第二个三角形用点vertices2,1和3构造.再一次,如果你注意图片,点vertices2,1和3构造第二个三角形(底部右边,顶端左边,底部左边).注意:两个三角形画点顺序相同.我看到很多的网站要求第二个三角形反方向画.这是不对的.Opengl从新整理顶点来保证所有的三角形为同一方向!注意:你在屏幕上看见的三角形个数是你叙述的顶点的个数减2.在程序中在我们有4个顶点,所以我们看见二个三角形

```c
            glTexCoord2d(1,1); glVertex3f(x+0.5f,y+0.5f,z);
            glTexCoord2d(0,1); glVertex3f(x-0.5f,y+0.5f,z);
            glTexCoord2d(1,0); glVertex3f(x+0.5f,y-0.5f,z);
            glTexCoord2d(0,0); glVertex3f(x-0.5f,y-0.5f,z);
```


最后我们告诉Opengl我们画完三角形带

```c
            glEnd();
```

现在我们能移动粒子.下面公式可能看起来很奇怪,其实很简单.首先我们取得当前粒子的x位置.然后把x运动速度加上粒子被减速1000倍后的值.所以如果粒子在x轴(0)上屏幕中心的位置,运动值(xi)为x轴方向+10(移动我们为右),而slowdown等于1,我们移向右边以10/(1*1000)或 0.01f速度.如果增加slowdown值到2我们只移动0.005f.希望能帮助你了解slowdown如何工作.那也是为什么用10.0f乘开始值来叫象素移动快速,创造一个爆发效果.y和z轴用相同的公式来计算附近移动粒子

```c
            particle[loop].x+=particle[loop].xi/(slowdown*1000); // 更新X坐标的位置
            particle[loop].y+=particle[loop].yi/(slowdown*1000); // 更新Y坐标的位置
            particle[loop].z+=particle[loop].zi/(slowdown*1000); // 更新Z坐标的位置
```

在计算出下一步粒子移到那里,开始考虑重力和阻力.在下面的第一行,将阻力(xg)和移动速度(xi)相加.我们的移动速度是10和阻力是1.每时每刻粒子都在抵抗阻力.第二次画粒子时,阻力开始作用,移动速度将会从10掉到9.第三次画粒子时,阻力再一次作用,移动速度降低到8.如果粒子燃烧为超过10次重画,它将会最后结束,并向相反方向移动.因为移动速度会变成负值.阻力同样使用于y和z移动速度  

```c
            particle[loop].xi+=particle[loop].xg;  // 更新X轴方向速度大小
            particle[loop].yi+=particle[loop].yg;  // 更新Y轴方向速度大小
            particle[loop].zi+=particle[loop].zg;  // 更新Z轴方向速度大小
```

下行将粒子的生命减少.如果我们不这么做,粒子无法烧尽.我们用粒子当前的life减去当前的fade值.每粒子都有不同的fade值,因此他们全部将会以不同的速度烧尽

```c
            particle[loop].life-=particle[loop].fade; // 减少粒子的生命值
```

现在我们检查当生命为零的话粒子是否活着

```c
            if (particle[loop].life<0.0f)   // 如果粒子生命值小于0
            {
```

如果粒子是小时(烧尽),我们将会使它复原.我们给它全值生命和新的衰弱速度. 

```c
                particle[loop].life=1.0f;  // 产生一个新的粒子
                particle[loop].fade=float(rand()%100)/1000.0f+0.003f; // 随机生成衰减速率
```

我们也重新设定粒子在屏幕中心放置.我们重新设定粒子的x,y和z位置为零 

```c
                particle[loop].x=0.0f;   // 新粒子出现在屏幕的中央
                particle[loop].y=0.0f;   
                particle[loop].z=0.0f;   
```


在粒子从新设置之后,将给它新的移动速度/方向.注意:我增加最大和最小值,粒子移动速度为从50到60的任意值,但是这次我们没将移动速度乘10.我们这次不想要一个爆发的效果,而要比较慢地移动粒子.也注意我把xspeed和x轴移动速度相加,y轴移动速度和yspeed相加.这个控制粒子的移动方向. 

```c
                particle[loop].xi=xspeed+float((rand()%60)-32.0f); // 随机生成粒子速度
                particle[loop].yi=yspeed+float((rand()%60)-30.0f); 
                particle[loop].zi=float((rand()%60)-30.0f); 
```

最后我们分配粒子一种新的颜色.变量col保存一个数字从1到11(12种颜色),我们用这个变量去找红,绿,蓝亮度在颜色箱里面.下面第一行表示红色的强度,数值保存在colors[col][0].所以如果col是0,红色的亮度就是1.0f.绿色的和蓝色的值用相同的方法读取.如果你不了解为什么红色亮度为1.0f那col就为0.我将一点点的解释.看着程序的最前面.找到那行:static GLfloat colors[12][3].注意:12行3列.三个数字的第一行是红色强度.第二行是绿色强度而且第三行是蓝色强度.[0],[1]和[2]下面描述的1st,2nd和3rd就是我刚提及的.如果col等于0,我们要看第一个组.11 是最後一个组(第12种颜色).

最后我们分配粒子一种新的颜色.变量col保存一个数字从1到11(12种颜色),我们用这个变量去找红,绿,蓝亮度在颜色箱里面.下面第一行表示红色的强度,数值保存在colors[col][0].所以如果col是0,红色的亮度就是1.0f.绿色的和蓝色的值用相同的方法读取.如果你不了解为什么红色亮度为1.0f那col就为0.我将一点点的解释.看着程序的最前面.找到那行:static GLfloat colors[12][3].注意:12行3列.三个数字的第一行是红色强度.第二行是绿色强度而且第三行是蓝色强度.[0],[1]和[2]下面描述的1st,2nd和3rd就是我刚提及的.如果col等于0,我们要看第一个组.11 是最後一个组(第12种颜色).

  

```c
                particle[loop].r=colors[col][0];  // 设置粒子颜色
                particle[loop].g=colors[col][1];  
                particle[loop].b=colors[col][2];  
			}
```

下行描述加速度的数值是多少.通过小键盘8号键,我们增加yg(y 地心引力)值.这引起向上的力.如果这个程序在循环外面,那么我们必须生成另一个循环做相同的工作,因此我们最好放在这里

```c
            // 如果小键盘8被按住，增加Y轴方向的加速度
            if (keys[VK_NUMPAD8] && (particle[loop].yg<1.5f)) particle[loop].yg+=0.01f;
```

这行是产生相反的效果.通过2号键,减小yg值,引起向下的力

```c
            // 如果小键盘2被按住，减少Y轴方向的加速度
            if (keys[VK_NUMPAD2] && (particle[loop].yg>-1.5f)) particle[loop].yg-=0.01f;
```

现在更改向右的拉力.如果按下6号键时增加向右的拉力.

```c
            // 如果小键盘6被按住，增加X轴方向的加速度
            if (keys[VK_NUMPAD6] && (particle[loop].xg<1.5f)) particle[loop].xg+=0.01f;
```

最后如果4号键被按下则增加向左的拉力.这些按键给了我们很酷的结果.举例来说:你可以用粒子造一条向上设的水流.通过增加向下的引力可以形成泉水

```c
            // 如果小键盘4被按住，减少X轴方向的加速度
            if (keys[VK_NUMPAD4] && (particle[loop].xg>-1.5f)) particle[loop].xg-=0.01f;
```


我仅仅为乐趣增加了一些代码.我的兄弟产生很棒的效果:)通过按住tab键所有粒子都回到屏幕中心.所有的粒子在从新开始运动,再产生一个大的爆发.在粒子变弱之后,你最初的效果会再一次出现

```c
            if (keys[VK_TAB])   // 按Tab键，使粒子回到原点
            {
                particle[loop].x=0.0f;   
                particle[loop].y=0.0f;   
                particle[loop].z=0.0f;   
                particle[loop].xi=float((rand()%50)-26.0f)*10.0f; // 随机生成速度
                particle[loop].yi=float((rand()%50)-25.0f)*10.0f; 
                particle[loop].zi=float((rand()%50)-25.0f)*10.0f; 
            }
		}
	}
	return TRUE;     // 绘制完毕成功返回
}
```

代码KillGLWindow(),CreateGLWindow()和WndProc()中没有改变,所以我们直接跳到WinMain().我将重写代码 


我喜欢简单的代码.在一行上不想包含很多东西,所以使代码象一个清洁工:)下面的代码检查"+"是否被按下.如果它和slowdown一起实现则slowdown减少0.01f.粒子就可以较快速地移动.

```c
if (keys[VK_ADD] && (slowdown>1.0f)) slowdown-=0.01f; // 按+号，加速粒子
```

下面的代码检查"-"是否被按下.如果它和slowdown一起实现则slowdown增加0.01f.粒子就可以较慢速地移动.我实质的极限是4.0f,我不想它太慢的运动,你可以随你的要求改变最大最小值 

```c
if (keys[VK_SUBTRACT] && (slowdown<4.0f)) slowdown+=0.01f; // 按-号，减速粒子
```

下面的代码检测Page Up是否被按下.如果是,则zoom增加.从而导致粒子靠近我们 

```c
if (keys[VK_PRIOR]) zoom+=0.1f; // 按Page Up键，让粒子靠近视点
```

下行代码检测Page Down是否别按下,如果是,则zoom减小.从而导师粒子离开我们

```c
if (keys[VK_NEXT]) zoom-=0.1f; // 按Page Down，让粒子远离视点
```

下面的代码检验enter键是否被按下.如果是,并且没有被一直按着,我们将让计算机把rp变为true,然后我们固定彩虹模式.如果彩虹模式为true,将其变成false.如果为false,将其变成true.最后一行检测enter是否被释放,如果释放rp为false并告诉计算机该键不被按下

```c
if (keys[VK_RETURN] && !rp) // 按住回车键，切换彩虹模式
{
    rp=true;  
    rainbow=!rainbow; 
}
if (!keys[VK_RETURN]) rp=false; 
```

下面程序有点乱.第一行检查space键是否被按下并没有没一直按着.并检查彩虹模式是否开始运行,如果是,检查delay是否大于25.delay是我创建的显示彩虹效果的数值.如果你曾经改变颜色结构,粒子将显示不同颜色.通过创建一个delay,在颜色改变之前,一组粒子将是一种颜色.如果space按下,彩虹运行,delay值大于25则颜色改变

下面程序有点乱.第一行检查space键是否被按下并没有没一直按着.并检查彩虹模式是否开始运行,如果是,检查delay是否大于25.delay是我创建的显示彩虹效果的数值.如果你曾经改变颜色结构,粒子将显示不同颜色.通过创建一个delay,在颜色改变之前,一组粒子将是一种颜色.如果space按下,彩虹运行,delay值大于25则颜色改变

  

```c
if ((keys[' '] && !sp) || (rainbow && (delay>25))) // 空格键，变换颜色
{
```

下面行是为了当space按下则彩虹关掉而设置的.如果我们不关掉彩虹模式,颜色会继续变化直到enter再被按下.也就是说人们按下space来代替enter是想叫粒子颜色自己变化 

```c
    if (keys[' ']) rainbow=false; 
```

如果space键被按下,或者彩虹模式已开始,并且delay大于25,我们叫计算机知道space键被按下通过叫sp为true.然后我们将delay设定回0以便它能在到25.最后我们增加col的值以便它通过颜色箱里面改变成另一个颜色. 

```c
    sp=true;  
    delay=0;  
    col++;  
```


如果颜色值大于11,我们把它重新设为零.如果我们不重新设定为零,程序将去找第13颜色.而我们只有12种颜色!寻找不存在的颜色将会导致程序瘫痪 

```c
	if (col>11) col=0;
}
```

最后如果space键不被按下,我们将sp设为false。 

```c
if (!keys[' ']) sp=false; // 如果释放空格键，记录这个状态
```

现在对粒子增加一些控制.还记得我们从开始定义的2变量么?一个xspeed,一个yspeed.在粒子燃尽之后,我们给它新的移动速度且把新的速度加入到xspeed和yspeed中.这样当粒子被创建时将影响粒子的速度. 举例来说:粒子在x轴上的速度为5在y轴上的速度为0.当我们减少xspeed到-10,我们将以-10(xspeed)+5(最初的移动速度)的速度移动.这样我们将以5的速度向左移动.明白了么??无论如何,下面的代码检测UP是否被按下.如果它,yspeed将增加这将引起粒子向上运动.最大速度不超过200.速度在快就不好看了

```c
// 按上增加粒子Y轴正方向的速度
if (keys[VK_UP] && (yspeed<200)) yspeed+=1.0f;
```

这行检查Down键是否被按下,如果它是,yspeed将减少.这将引起粒子向下运动.再一次,最大速度为200 

```c
// 按下减少粒子Y轴正方向的速度
if (keys[VK_DOWN] && (yspeed>-200)) yspeed-=1.0f;
```

现在我们检查Right键是否被按下.如果它是..xspeed将被增加.粒子将移到右边.最大速度为200 

```c
// 按右增加粒子X轴正方向的速度
if (keys[VK_RIGHT] && (xspeed<200)) xspeed+=1.0f;
```

最后我们检查Left键是否被按下.如果是...你猜....xspeed被减小,粒子开始向左移动.最大速度为200 

```c
// 按左减少粒子X轴正方向的速度
if (keys[VK_LEFT] && (xspeed>-200)) xspeed-=1.0f;
```

最后我们要增加delay的数值.像我在前面所说,delay是控制彩色变化的 

```c
delay++;  // 增加彩虹模式的颜色切换延迟
```


在课程中,我试着把所有细节都讲清楚,并且简单的了解粒子系统.这个粒子系统能在游戏产生例如火,水,雪,爆炸,流行等效果.程序能简单的修改参数来实现新的效果(例:烟花效果)

# 第二十课 蒙板

到目前为止你已经学会如何使用alpha混合，把一个透明物体渲染到屏幕上了，但有的使用它看起来并不是那么的复合你的心意。使用蒙板技术，将会按照你蒙板的位置精确的绘制。

欢迎来到第20课的教程，*.bmp图像被给各种操作系统所支持，因为它简单，所以可以很轻松的作为纹理图片加载它。知道现在，我们在把图像加载到屏幕上时没有擦除背景色，因为这样简单高效。但是效果并不总是很好。
大部分情况下，把纹理混合到屏幕，纹理不是太少就是太多。当使用精灵时，我不希望背景从精灵的缝隙中透出光来；但在显示文字时，你希望文字的间隙可以显示背景色。

由于以上原因，我们需要使用“掩模”。使用“掩模”需要两个步骤，首先我们在场景上放置黑白相间的纹理，白色代表透明部分，黑色代表不透明部分。接着我们使用一种特殊的混合方式，只有在黑色部分上的纹理才会显示在场景中。

我只重写那些改变的地方，如果你做好了学习的准备，我们就上路吧。

在这个程序里，我们使用7个全局变量。变量masking为一个布尔值，标志是否使用“掩模”。变量mp标志键M是否按下，变量sp标志空格是否按下。
接着我们创建保存5个纹理标志的数组，loop为循环变量。变量roll使得纹理沿屏幕滚动。

```c
bool masking=TRUE;   // 是否使用“掩模”
bool mp;   // 键M是否按下
bool sp;   // 空格是否按下
bool scene;   // 绘制那一个场景

GLuint texture[5];   // 保存5个纹理标志
GLuint loop;   // 循环变量

GLfloat roll;   // 滚动纹理
```

加载纹理代码基本没变，只是这里我们需要加载5个纹理 

```c
int LoadGLTextures()   
{
    int Status=FALSE;   
    AUX_RGBImageRec *TextureImage[5];  // 创建保存5个纹理的数据结构
    memset(TextureImage,0,sizeof(void *)*5);  // 初始化

    if ((TextureImage[0]=LoadBMP("Data/logo.bmp")) && // 加载纹理0
        (TextureImage[1]=LoadBMP("Data/mask1.bmp")) && // 加载掩模纹理1，作为“掩模”使用
        (TextureImage[2]=LoadBMP("Data/image1.bmp")) && // 加载纹理1
        (TextureImage[3]=LoadBMP("Data/mask2.bmp")) && // 加载掩模纹理2，作为“掩模”使用
        (TextureImage[4]=LoadBMP("Data/image2.bmp"))) // 加载纹理2
    {
        Status=TRUE;   
        glGenTextures(5, &texture[0]);  // 创建5个纹理

        for (loop=0; loop<5; loop++)  // 循环加载5个纹理
        {
            glBindTexture(GL_TEXTURE_2D, texture[loop]);
            glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
            glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
            glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[loop]->sizeX, TextureImage[loop]->sizeY,
                         0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[loop]->data);
        }
    }
    for (loop=0; loop<5; loop++)   
    {
        if (TextureImage[loop])   
        {
            if (TextureImage[loop]->data)  
            {
                free(TextureImage[loop]->data); 
            }
            free(TextureImage[loop]);  
        }
    }
    return Status;   
}
```

改变窗口大小和初始化OpenGL的函数没有变化
现在到了最有趣的绘制部分了，我们从清楚背景色开始，接着把物体移入屏幕2个单位。 

```c
int DrawGLScene(GLvoid) 
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);  
    glLoadIdentity();    
    glTranslatef(0.0f,0.0f,-2.0f);   // 物体移入屏幕2个单位
```

下面一行，我们选择'logo'纹理。我们将要通过四边形把纹理映射到屏幕，并按照顶点的顺序设置纹理坐标。
Jonathan Roy说OpenGL是一个基于顶点的图形系统，大部分你设置的参数是作为顶点的属性而记录的，纹理坐标就是这样一种属性。你只要简单的设置各个顶点的纹理坐标，OpenGL就自动帮你把多边形内部填充纹理，通过一个插值的过程。

下面一行，我们选择'logo'纹理。我们将要通过四边形把纹理映射到屏幕，并按照顶点的顺序设置纹理坐标。
Jonathan Roy说OpenGL是一个基于顶点的图形系统，大部分你设置的参数是作为顶点的属性而记录的，纹理坐标就是这样一种属性。你只要简单的设置各个顶点的纹理坐标，OpenGL就自动帮你把多边形内部填充纹理，通过一个插值的过程。

向前面几课一样，我们假定四边形面对我们，并把纹理坐标(0,0)绑定到左下角，(1,0)绑定到右下角，(1,1)绑定到右上角。给定这些设置，你应该能猜到四边形中间对应的纹理坐标为(0.5,0.5)，但你自己并没有设置此处的纹理坐标！OpenGL为你做了计算。

在这一课里，我们通过设置纹理坐标达到一种滚动纹理的目的。纹理坐标是被归一化的，它的范围从0.0-1.0，值0被映射到纹理的一边，值1被映射到纹理的另一边。超过1的值，纹理可以按照不同的方式被映射，这里我们设置为它将回绕道另一边并重复纹理。例如如果使用这样的映射方式，纹理坐标(0.3,0.5)和(1.3,0.5)被映射到同一个纹理坐标。在这一课里，我们将尝试一种无缝填充的效果。

我们使用roll变量去设置纹理坐标，当它为0时，它把纹理的左下角映射到四边形的左下角。当它大于0时，把纹理的左上角映射到四边形的左下角，看起来的效果就是纹理沿四边形向上滚动。 

```c
    glBindTexture(GL_TEXTURE_2D, texture[0]);  // 选择Logo纹理
    glBegin(GL_QUADS);    // 绘制纹理四边形
    glTexCoord2f(0.0f, -roll+0.0f); glVertex3f(-1.1f, -1.1f, 0.0f); 
    glTexCoord2f(3.0f, -roll+0.0f); glVertex3f( 1.1f, -1.1f, 0.0f); 
    glTexCoord2f(3.0f, -roll+3.0f); glVertex3f( 1.1f, 1.1f, 0.0f); 
    glTexCoord2f(0.0f, -roll+3.0f); glVertex3f(-1.1f, 1.1f, 0.0f); 
    glEnd(); 
```

启用混合和禁用深度测试 

启用混合和禁用深度测试 

```c
    glEnable(GL_BLEND);    // 启用混合
    glDisable(GL_DEPTH_TEST);    // 禁用深度测试
```

接下来我们需要根据masking的值设置是否使用“掩模”，如果是，则需要设置相应的混合系数。 

```c
    if (masking)    // 是否启用“掩模”
    {
```

如果启用了“掩模”，我们将要设置“掩模”的混合系数。一个“掩模”只是一幅绘制到屏幕的纹理图片，但只有黑色和白色。白色的部分代表透明，黑色的部分代表不透明。
下面这个混合系数使得，任何对应“掩模”黑色的部分会变为黑色，白色的部分会保持原来的颜色。

```c
    	glBlendFunc(GL_DST_COLOR,GL_ZERO);   // 使用黑白“掩模”混合屏幕颜色
    }
```

现在我们检查绘制那一个层，如果为True绘制第二个层，否则绘制第一个层 

```c
    if (scene) 
    {
```

为了不使它看起来显得非常大，我们把它移入屏幕一个单位，并把它按roll变量的值进行旋转（沿Z轴）。 

```c
        glTranslatef(0.0f,0.0f,-1.0f);   // 移入屏幕一个单位
        glRotatef(roll*360,0.0f,0.0f,1.0f);   // 沿Z轴旋转
```

接下我们检查masking的值来绘制我们的对象 

```c
        if (masking)    // “掩模”是否打开
        {
```

如果“掩模打开”，我们会把掩模绘制到屏幕。当我们完成这个操作时，将会看到一个镂空的纹理出现在屏幕上。 

```c
            glBindTexture(GL_TEXTURE_2D, texture[3]); // 选择第二个“掩模”纹理
            glBegin(GL_QUADS);   // 开始绘制四边形
            glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.1f, -1.1f, 0.0f); 
            glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.1f, -1.1f, 0.0f); 
            glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.1f, 1.1f, 0.0f); 
            glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.1f, 1.1f, 0.0f); 
            glEnd();   
        }
```

当我们把“掩模”绘制到屏幕上后，接着我们变换混合系数。这次我们告诉OpenGL把任何黑色部分对应的像素复制到屏幕，这样看起来纹理就像被镂空一样帖子屏幕上。
注意，我们在变换了混合模式后在选择的纹理。

如果我们没有使用“掩模”，我们的图像将与屏幕颜色混合。

```c
        glBlendFunc(GL_ONE, GL_ONE);  // 把纹理2复制到屏幕
        glBindTexture(GL_TEXTURE_2D, texture[4]);  // 选择第二个纹理
        glBegin(GL_QUADS);   // 绘制四边形
        glTexCoord2f(0.0f, 0.0f); glVertex3f(-1.1f, -1.1f, 0.0f); 
        glTexCoord2f(1.0f, 0.0f); glVertex3f( 1.1f, -1.1f, 0.0f); 
        glTexCoord2f(1.0f, 1.0f); glVertex3f( 1.1f, 1.1f, 0.0f); 
        glTexCoord2f(0.0f, 1.0f); glVertex3f(-1.1f, 1.1f, 0.0f); 
        glEnd();   
	}
```

绘制第一层图像 

```c
    else     
    {
```

如果“掩模打开”，我们会把掩模绘制到屏幕。当我们完成这个操作时，将会看到一个镂空的纹理出现在屏幕上。 

```c
        if (masking)    // “掩模”是否打开
        {
```

如果“掩模打开”，我们会把掩模绘制到屏幕。当我们完成这个操作时，将会看到一个镂空的纹理出现在屏幕上。 

```c
            glBindTexture(GL_TEXTURE_2D, texture[1]); // 选择第一个“掩模”纹理
            glBegin(GL_QUADS);   // 开始绘制四边形
            glTexCoord2f(roll+0.0f, 0.0f); glVertex3f(-1.1f, -1.1f, 0.0f); 
            glTexCoord2f(roll+4.0f, 0.0f); glVertex3f( 1.1f, -1.1f, 0.0f); 
            glTexCoord2f(roll+4.0f, 4.0f); glVertex3f( 1.1f, 1.1f, 0.0f); 
            glTexCoord2f(roll+0.0f, 4.0f); glVertex3f(-1.1f, 1.1f, 0.0f); 
            glEnd();   
		}
```

当我们把“掩模”绘制到屏幕上后，接着我们变换混合系数。这次我们告诉OpenGL把任何黑色部分对应的像素复制到屏幕，这样看起来纹理就像被镂空一样帖子屏幕上。
注意，我们在变换了混合模式后在选择的纹理。

如果我们没有使用“掩模”，我们的图像将与屏幕颜色混合。

```c
        glBlendFunc(GL_ONE, GL_ONE);   // 把纹理1复制到屏幕
        glBindTexture(GL_TEXTURE_2D, texture[2]);  // 选择第一个纹理
        glBegin(GL_QUADS);    // 开始绘制四边形
        glTexCoord2f(roll+0.0f, 0.0f); glVertex3f(-1.1f, -1.1f, 0.0f); 
        glTexCoord2f(roll+4.0f, 0.0f); glVertex3f( 1.1f, -1.1f, 0.0f); 
        glTexCoord2f(roll+4.0f, 4.0f); glVertex3f( 1.1f, 1.1f, 0.0f); 
        glTexCoord2f(roll+0.0f, 4.0f); glVertex3f(-1.1f, 1.1f, 0.0f); 
        glEnd();  
	}
```

接下来启用深度测试，禁用混合。 

```c
    glEnable(GL_DEPTH_TEST);    // 启用深度测试
    glDisable(GL_BLEND);    // 禁用混合
```

最后增加roll变量，如果大于1，把它的值减1。 

```c
    roll+=0.002f;    // 增加纹理滚动变量
    if (roll>1.0f)    // 大于1则减1
    {
        roll-=1.0f;   
    }

    return TRUE;    // 成功返回
}
```

函数KillGLWindow(), CreateGLWindow() 和 WndProc() 没有改变。

接下来在wWinMain，我们添加键盘控制函数。我们检查空格是否按下，如果是则设置sp变量为TRUE，sp变量用来切换场景。 

```c
if (keys[' '] && !sp)  // 空格键是否被按下?
{
    sp=TRUE;  
    scene=!scene;  // 是则切换场景
}
```

如果空格键释放，记录下来 

```c
if (!keys[' '])   // 如果空格键释放，记录下来
{
    sp=FALSE;  
}
```

我们检查M键是否按下，如果是则设置mp变量为TRUE，sp变量用来切换是否使用“掩模” 

```c
if (keys['M'] && !mp)  // M键是否被按下
{
    mp=TRUE;  
    masking=!masking;  // 是则切换“掩模”
}
```

如果M键释放，记录下来 

```c
if (!keys['M'])   // 如果M键释放，记录下来
{
    mp=FALSE;  
}
```

Eric Desrosiers指出，你也可以在载入的时候测试*.bmp图像中的每一个像素，如果你你想要透明的结果，你可以把颜色的alpha设置为0。对于其他的颜色，你可以把alpha设置为1。这个方法也能达到同样的效果，但需要一些额外的代码。
在这课里，我们给你演示了一个简单的例子，它能高效的绘制一部分纹理而不使用alpha值。

谢谢Rob Santa的想法和例子程序，我从没想到过这种方法。

我希望你喜欢这个教程，如果你在理解上有任何问题或找到了任何错误，请我知道，我想做最好的教程，你的反馈是非常重要的。