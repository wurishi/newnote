# 一. 教程

## 1. 安装

### 1.1 安装 TensorFlow.js

#### 选项1: 安装带有原生C++绑定的 TensorFlow.js.

```shell
npm install @tensorflow/tfjs-node
```

#### 选项2: (仅限Linux) 如果系统支持 CUDA 的 NVIDIA®GPU.

```shell
npm install @tensorflow/tfjs-node-gpu
```

#### 选项3: 安装纯 Javascript 版本, 这是性能方面最慢的选项.

```shell
npm install @tensorflow/tfjs
```

#### TypeScript

如果项目使用严格的空值检查, 或者在编译过程中遇到错误, 可能需要在 tsconfig.json 文件中设置 `skipLibCheck: true`.

### 1.2 安装可视化库

tfjs-vis 是一个用于在浏览器内实现可视化的小型库.

```shell
npm install @tensorflow/tfjs-vis
```



## 2. 将曲线拟合到二维数据

[代码](2/index.html)

### 2.1 介绍

训练模型根据一组汽车的数值数据进行预测.

因为要训练一个模型来预测连续数, 所以有时将此任务称为回归 (regression)任务. 

通过显示许多输入示例以及正确的输出来训练模型, 这被称为监督学习 (supervised learning)

### 2.2 设置

一个模板 index.html 文件, 和一个 script.js 用来 code.

### 2.3 加载数据

目标: 训练一个模型, 该模型根据一个 horsepower 预测 mpg.

### 2.4 定义模型

模型体系结构的含义是: "模型在执行时将运行哪些功能" 或 "模型将使用哪种算法来计算其答案".

ML模型是一种接受输入并产生输出的算法. 使用神经网络时, 该算法是一组神经元层, 其中"权重"控制着它们的输出. 训练过程即通过学习得到这些"权重"的理想值.

- 实例化模型

  ```javascript
  const model = tf.sequential();
  ```

  创建一个tf.Model对象, sequential表示模型的顺序是由输入直接向下流至输出的. 其他类型的模型可以具有分支, 甚至可以具有多个输入和输出.

- 创建输入层

  ```javascript
  model.add(
      tf.layers.dense({
        inputShape: [1],
        units: 1,
        useBias: true,
      })
    );
  ```

  为神经网络添加一个输入层, 该输入层会自动连接到带有一个隐藏单元的"密集"层. `dense`(密集)图层是一种图层类型, 将其输入乘以一个矩阵 (weights), 然后与一个数字 (bias) 相加. 由于这是第一层, 因此需要定义 `inputShape`. `inputShape: [1]`表示将数字1作为输入 (即汽车的horsepower).

  units: 设置权重矩阵在图层中的大小. 这里设置为1, 表示每个数据的输入权重都为1.

  useBias: 默认即为 true.

- 创建输出层

  ```javascript
  model.add(
      tf.layers.dense({
        units: 1,
        useBias: true,
      })
    );
  ```

- 创建一个实例

  ```javascript
  const model = createModel();
    tfvis.show.modelSummary({ name: "Model Summary" }, model);
  ```

### 2.5 准备训练数据

为了获得 TensorFlow.js 的性能优势, 需要将数据转换为张量. 并对数据进行一些最佳实践的转换, 改组和标准化.

- step1: 随机洗数据

  将数据随机分配给训练算法. 改组很重要, 因为通常在训练过程中, 数据集会被分成较小的子集, 改组可以让每个批次从整个数据分布中获取各种数据, 这样的好处是可以帮助模型:

  - 不学习纯粹依赖于数据输入顺序.
  - 对子组的结构不敏感 (例如: 如果在训练前半段只看到高马力的汽车, 它可能会发现一种不适用于其他数据集的关系)

- step2: 转换为张量

- step3: 规范化数据 (归一化)

  规范化很重要, 因为使用 tensorflow.js 构建的许多机器学习模型的内部设计为可以处理不太大的数字. 标准化范围一般为 `0 ~ 1` 或者通用范围 `-1 ~ 1`.

### 2.6 训练模型

- model.compile(optimizer, loss, metrics) :

  | 参数      | 含义                                                         |
  | --------- | ------------------------------------------------------------ |
  | optimizer | 优化器, 用于控制模型更新的算法, TensorFlow.js 提供了许多优化器. |
  | loss      | 此函数告诉模型学习每个批次 (数据子集) 时的性能如何.          |

- model.fit(inputs, labels, options) : 

  options 属性:

  | 属性      | 含义                                                         |
  | --------- | ------------------------------------------------------------ |
  | batchSize | 每次训练迭代的数据子集的大小, 常见批量大小通常在 32~512 之间. |
  | epochs    | 模型迭代整个数据集的次数.                                    |

### 2.7 作出预测

- 生成示例

  ```javascript
  const xs = tf.linspace(0, 1, 100);
  const preds = model.predict(xs.reshape([100, 1]));
  ```

  创建100个新的示例供模型使用.

- 数据反转

  ```javascript
  return [unNormXs.dataSync(), unNormPreds.dataSync()];
  ```

  将(0-1)的数据回到原始范围, 将数据根据归一化时的计算, 反转结果.

### 2.8 总结

训练机器学习模型的步骤包括:

#### 制定任务:

- 确定是回归问题还是分类问题?
- 可以通过有监督的学习还是无监督的学习来完成?
- 输入数据是什么样的? 输出的数据应该是什么样的?

#### 准备数据:

- 清理数据并在可能的情况下手动检查其是否有图形.
- 将数据用于训练之前要先 shuffle.
- 将数据标准化(归一化)到神经网络的合理范围内. 通常是 0~1 或者是 -1~1 范围.
- 将数据转换为张量.

#### 构建并运行模型:

- 定义模型.
- 选择一个优化器.
- 为问题选择适当的损失函数, 并选择一个准确度指标来评估进度.
- 查看训练进程中损失是否正在减少.

#### 评估模型:

- 为模型选择一个评估指标, 在训练过程中对其进行监控. 进行训练后, 尝试进行一些测试, 提高预测质量.

### 2.9 额外的尝试

- 尝试修改迭代的次数 (epochs).

- 尝试增加隐藏层中的单位数量.

- 尝试在第一个隐藏层和最终输出层之间添加更多的隐藏层.

  ```javascript
  model.add(tf.layers.dense({units: 50, activation: 'sigmoid'}));
  ```

## 3. 识别手写数字

[代码](3/index.html)

### 3.1 介绍

通过分类器 "观察" 数千个手写数字图像及其标签来训练分类器. 然后使用模型从未见过的测试数据来评估分类器的准确性.

该任务被视为分类任务, 因为我们正在训练模型以将出现在图像中的数字分配给输入图像.

通过显示许多输入示例以及正确的输出来训练模型, 这被称为监督学习.

### 3.2 设置

### 3.3 加载数据

### 3.4 构思任务

目标是训练一个拍摄一张图像的模型, 并学习预测该图像可能属于的数字 (数字 0~9)

每个图像宽28像素, 高28像素, 并具有1个颜色通道 (因为它是灰度图像). 因此, 每个图像的形状为 [28, 28, 1].

### 3.5 定义模型架构

损失函数: categoricalCrossentropy, 因为这里的模型输出的是概率分布, categoricalCrossentropy 会测量模型最后一层生成的概率分布与真实标签给出的概率分布之间的误差.

比如数字7, 可能会得到以下结果:

| 图片 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7        | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | -------- | ---- | ---- |
| 标签 | 0    | 0    | 0    | 0    | 0    | 0    | 0    | **1**    | 0    | 0    |
| 预测 | 0.1  | 0.01 | 0.01 | 0.01 | 0.20 | 0.01 | 0.01 | **0.60** | 0.03 | 0.02 |

这里用于标签的数据被称为 **one-hot encoding** , 在分类问题中很常见. 对于每个示例, 每个类别都有与之关联的概率. 当我们确切知道应该是什么时, 就可以将该概率设置1, 其它概率都设置为0.

### 3.6 训练模型

### 3.7 评估模型

### 3.8 总结

预测输入数据的类别称为分类任务.

#### 分类任务要求标签具有适当的数据形式

- 标签数据 one-hot encoding 是常见的形式.

#### 准备数据

- 组织一些训练期间未参与的数据作为评估模型时使用, 这组数据称为验证集.

#### 构建并运行模型

- 卷积模型在图像任务上表现良好.
- 分类问题通常使用 categoricalCrossentropy 作为损失函数.
- 监视训练以查看损失是否在减少并且准确性是否在增加.

#### 评估模型

- 一旦训练了模型以决定要解决的初始问题的性能如何, 就可以决定评估模型的方式.
- 观察每组数据的准确性和混淆矩阵可以提供比整体准确性更好的模型性能分析.

## 4. 在 Node.js 中预测棒球投球类型

### 4.1 介绍

使用 TensorFlow.js 构建 Node.js Web服务器, 在服务器端进行训练和分类, 并在 Web 客户端调用预测.

### 4.2 要求

### 4.3 安装 Node.js 应用

### 4.4 设置训练和测试数据

### 4.5 创建模型

### 4.6 在服务器上训练模型

### 4.7 客户端

### 4.8 运行应用

需要将 client 和 server 都运行.

## 5. 什么是迁移学习

复杂的深度学习模型通常有数百万的参数 (weights), 从头训练模型需要大量计算资源. 迁移学习就是指将已经在相关任务中训练过的模型的一部分利用到新模型中, 从而很大程度地降低对大量计算资源的需要.

## 6. 图像分类迁移学习

### 6.1 介绍

### 6.2 要求

### 6.3 加载 MobileNet 模型

### 6.4 使用 MobileNet 在浏览器中预测

### 6.5  在浏览器中测试 MobileNet

模型怎样下载到本地?

### 6.6 在浏览器中通过摄像头图像运行 MobileNet 预测

### 6.7 在 MobileNet 上添加自定义分类器

## 7. 语音识别的迁移学习

### 7.1 介绍

首先, 加载并运行一个可识别20条语音命令的预训练模型. 然后, 使用麦克风建立并训练一个简单的模型来识别声音并使滑块向左或向右移动.

### 7.2 要求

### 7.3 加载音频模型

### 7.4 实时预测

### 7.5 测试预测

### 7.6 收集数据

### 7.7 测试数据收集

### 7.8 训练模型

### 7.9 实时更新滑块

# 二. 指南

## 1. 张量 (Tensors) 和操作 (operations)

### 1.1 张量 (Tensors)

[代码](guide/1.1.js)

`tf.Tensor` 是 TensorFlow.js 中的最重要的数据单元, 它是一个形状为一维或多维数组组成的数值的集合.

`tf.Tensor` 和多维数组其实非常的相似.

一个 `tf.Tensor` 还包含如下属性:

- rank: 张量的维度
- shape: 每个维度的数据大小
- dtype: 张量中的数据类型

> 注释: 后面也会用术语"维度 (dimension)"表示 rank (秩). 在机器学习中, 张量的"维数 (dimensionality)"有时也指特定维度的大小.
>
> 例如: 一个形状为 [10, 5] 的矩阵是一个 rank-2 的张量, 或者可以说成一个 2- 维的张量. 第一个维度的维数是10.

可以用 `tf.tensor()` 方法将一个数组(array)创建为一个 `tf.Tensor` 

在默认情况下, `tf.Tensor` 的数据类型是 `dtype` 即32位浮点型(`float32`). 当然 `tf.Tensor` 也可以被创建为以下数据类型: 布尔(`bool`), 32位整型(`int32`), 64位复数(`complex64`)和字符串(`string`).

TensorFlow.js 同样也提供了一系列方便的模式用作创建随机张量, 比如将张量填入特定的数值或是从 `HTMLImageElement` 中获取张量.

#### 修改张量的形状

`tf.Tensor` 中的元素数量是这个张量的形状的乘积(例如一个形状为[2,3]的张量所含有的元素个数为2*3=6个). 所以在大部分情况下不同形状的张量的大小却是相同的, 那么将一个 `tf.Tensor` 改变形状(reshape)成为另外一个形状通常是有用且有效的.

#### 获取张量的值

如果想要获取一个 `tf.Tensor` 的值, 可以使用 `Tensor.array()` 或 `Tensor.data()` 这两个方法.

> Tensor.array() 和 Tensor.data() 都是异步方法, 它们也有对应的同步执行版本, Tensor.arraySync() 和 Tensor.dataSync()

### 1.2 操作

[代码](guide/1.2.js)

因为张量是不可变的, 所以所有操作运算并不会更改 Tensor 本身的值, 而是返回一个新的 `tf.Tensor`

> 注释: 大部分的操作会同步返回 tf.Tensor , 然而结果可能不会立刻被计算出来. 这意味着得到的 tf.Tensor 实际上是计算的一个句柄. 当调用 Tensor.data() 或 Tensor.array() 时, 这些方法将会等待计算完成之后才将数值解析出来. 所以应该始终优先选择这些方法的异步版本而不是同步版本, 以避免计算过程中阻塞 UI 线程.

### 1.3 内存

[代码](guide/1.3.js)

当使用 WebGL 时, `tf.Tensor` 的内存必须显式管理. 这是因为 WebGL 不足以让 `tf.Tensor` 超出生命周期后自动释放内存.

- tf.tidy() : 一个应用程序中, 将多个操作链接在一起是非常常见的. 保存所有中间变量的引用并手动释放它们所占用的空间会降低代码的可读性. 为了解决这个问题, 可以使用 `tf.dity()` 方法, 这个方法可以清除所有在执行函数后没有返回的 tf.Tensor, 这和执行函数时清除一些局部变量的方法有些类似.
- tf.memory() : 获取 TensorFlow.js 中张量的数量.